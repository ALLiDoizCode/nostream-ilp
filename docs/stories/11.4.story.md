# Story 11.4: Real Dassie Integration Tests

**Epic:** 11 - BTP-NIPs N-Peer Network Verification
**Status:** Blocked (Pending Stories 5.9 and 5.10)
**Priority:** High (Critical Path)
**Estimated Effort:** 5 days
**Created:** 2025-12-16
**Dependencies:** Story 11.1 (Test Framework), Story 5.9 (Dassie tRPC Endpoints), Story 5.10 (Dassie BTP-NIPs Reception), Epic 6 (Peer Networking)
**Execution Mode:** Docker Containers (Real Dassie Nodes)

---

## Story

**As a** QA Engineer  
**I want** to replace MockStreamConnection with real Dassie ILP nodes running in Docker containers  
**So that** I can verify the protocol works correctly with actual ILP routing, real network TCP connections, and production-like settlement

---

## Acceptance Criteria

### AC 1: Docker Compose Infrastructure for N Dassie Nodes

**Given** a test requiring real Dassie integration  
**When** creating a 5-node Docker network  
**Then** the system should:
- ✅ Spin up 5 Dassie node containers (dassie-node-0 through dassie-node-4)
- ✅ Each container runs independent Dassie process with unique config
- ✅ Docker network created with subnet (e.g., 172.20.0.0/16)
- ✅ Each node has static IP for predictable addressing
- ✅ PostgreSQL and Redis services available to all nodes
- ✅ All containers healthy and ready within 30 seconds
- ✅ Inter-node communication verified (ping between containers)

**Docker Compose Configuration:**
```yaml
services:
  dassie-node-0:
    image: dassie:latest
    networks:
      n-peer-test:
        ipv4_address: 172.20.0.10
    volumes:
      - ./config/node-0:/app/config
    environment:
      - ILP_ADDRESS=g.dassie.node0
      - NODE_ID=0
  # ... nodes 1-4 similar
  postgres:
    image: postgres:16
    networks:
      - n-peer-test
  redis:
    image: redis:7
    networks:
      - n-peer-test
```

### AC 2: ILP STREAM Connection Establishment

**Given** 2 Dassie nodes running in Docker
**When** establishing ILP STREAM connection between them
**Then** the system should:
- ✅ Node 0 sends connection request to Node 1's HTTP API
- ✅ Nodes exchange public keys and establish shared secret
- ✅ ILP STREAM connection established (encrypted)
- ✅ Heartbeat messages sent every 5-20 seconds (Dassie adaptive interval)
- ✅ Connection remains stable for 5 minutes
- ✅ Connection state: PENDING → ESTABLISHED → ACTIVE

**Connection Metrics:**
- ✅ Connection establishment time: < 2 seconds
- ✅ Round-trip latency: < 50ms (local Docker network)
- ✅ No packet loss (0% loss rate)

**Note:** Heartbeat interval is adaptive between MIN_HEARTBEAT_INTERVAL (5s) and MAX_HEARTBEAT_INTERVAL (20s) per Dassie source code.

### AC 3: Multi-Hop ILP Payment Through Real Dassie Network

**Given** a 5-node Dassie network in Docker (Node 0 → 1 → 2 → 3 → 4)  
**When** Node 0 sends a 100 msat payment to Node 4  
**Then** the system should:
- ✅ Payment routed through intermediate nodes (1, 2, 3)
- ✅ Each node deducts routing fee (configurable)
- ✅ Final payment delivered to Node 4
- ✅ Payment fulfillment propagates back to Node 0
- ✅ All nodes update internal ledger (double-entry accounting)
- ✅ End-to-end payment latency: < 500ms (p95)

**Verify Dassie Internal Ledger:**
- ✅ Node 0: Debit 100 msats from `ilp:assets/settlement`
- ✅ Node 1: Credit from Node 0, Debit to Node 2 (minus fee)
- ✅ Node 4: Credit 50 msats to `ilp:liabilities/settlement`

### AC 4: BTP-NIPs EVENT Message Over Real ILP STREAM

**Given** 2 Dassie nodes with BTP-NIPs integration  
**When** Node 0 publishes a Nostr event to Node 1  
**Then** the system should:
- ✅ Serialize event into BTP-NIPs packet format
- ✅ Wrap packet in ILP PREPARE message
- ✅ Send via Dassie ILP STREAM connection
- ✅ Node 1 receives and deserializes packet
- ✅ Node 1 verifies Nostr signature
- ✅ Node 1 stores event in PostgreSQL
- ✅ Node 1 sends ILP FULFILL back to Node 0
- ✅ Node 0 confirms payment settled

**End-to-End Metrics:**
- ✅ Total latency (publish → confirm): < 200ms (p95)
- ✅ Success rate: 100% (no dropped packets)

### AC 5: Dassie Peering (BNL/KNL Integration)

**Given** 5 Dassie nodes starting with empty peer lists  
**When** bootstrapping network via BNL (Bootstrap Node List)  
**Then** the system should:
- ✅ Node 0 configured with hardcoded BNL (Node 1's address)
- ✅ Node 0 downloads KNL (Known Node List) from Node 1
- ✅ Node 0 discovers Nodes 2, 3, 4 via gossip
- ✅ Full mesh connectivity established within 60 seconds
- ✅ All nodes aware of all other nodes (5-node full mesh)
- ✅ Routing table complete (each node knows paths to all others)

**Verify Peering State:**
- ✅ Each node has 4 active peer connections
- ✅ Heartbeat messages exchanged every 10 seconds
- ✅ No peer disconnections during 5-minute observation period

### AC 6: Real Settlement Between Dassie Nodes

**Given** Dassie nodes configured with settlement layer (simulated blockchain)  
**When** liquidity imbalance exceeds threshold (e.g., 10,000 msats)  
**Then** the system should:
- ✅ Trigger settlement process automatically
- ✅ Settlement transaction created (simulated on-chain tx)
- ✅ Balances rebalanced between nodes
- ✅ Internal ledgers updated to reflect settlement
- ✅ Payment routing can continue immediately after settlement

**Settlement Verification:**
- ✅ Node balances accurately track all payments
- ✅ No "lost" funds (conservation of value)
- ✅ Settlement latency: < 5 seconds (simulated blockchain)

### AC 7: Docker Resource Limits and Monitoring

**Given** 10 Dassie nodes running in Docker  
**When** monitoring resource usage  
**Then** the system should respect limits:

**Per-Node Resource Limits:**
- ✅ Memory: < 512MB per node
- ✅ CPU: < 50% per node (1 CPU core)
- ✅ Network: < 10 Mbps per node

**Monitoring:**
- ✅ `docker stats` shows real-time resource usage
- ✅ Alert if any node exceeds limits
- ✅ Total resource usage: < 8GB RAM (10 nodes × 512MB + overhead)

### AC 8: Failover and Reconnection

**Given** an active ILP STREAM connection between 2 nodes  
**When** intermediate container is restarted  
**Then** the system should:
- ✅ Detect connection loss (heartbeat timeout)
- ✅ Attempt reconnection (exponential backoff: 1s, 2s, 4s, 8s)
- ✅ Re-establish connection within 15 seconds
- ✅ Resume payment routing after reconnection
- ✅ No payments lost during reconnection

**Resilience Metrics:**
- ✅ Maximum downtime: 15 seconds
- ✅ No data loss (all payments queued and retried)

### AC 9: Performance Under Docker Network Constraints

**Given** 10 Dassie nodes in Docker with network simulation  
**When** adding latency (50ms) and packet loss (0.1%) via `tc` (traffic control)  
**Then** the system should:
- ✅ Payments still complete successfully
- ✅ Latency increases proportionally (expected: +50ms per hop)
- ✅ Retries handle packet loss gracefully
- ✅ No cascading failures from network issues

**Performance Targets:**
- ✅ 5-hop payment with 50ms latency: < 500ms total (p95)
- ✅ Success rate: > 99% (with 0.1% packet loss)

### AC 10: CI/CD Docker Compose Integration

**Given** GitHub Actions CI/CD environment  
**When** running Dassie integration tests in CI  
**Then** the system should:
- ✅ Docker Compose stack starts in < 60 seconds
- ✅ All tests complete within 15 minutes (Tier 2 budget)
- ✅ Containers cleaned up after tests (no resource leaks)
- ✅ Test results published to PR
- ✅ Docker logs available as artifacts for debugging

---

## Tasks/Subtasks

### 1. Docker Infrastructure Setup
- [x] Write Dockerfile for Dassie node (reused existing docker/Dockerfile.dassie)
- [x] Create docker-compose.yml for N-node stack
- [x] Configure static IP addressing
- [x] Set up shared PostgreSQL/Redis
- [x] Create initialization scripts (DB schema, config)

### 2. Dassie Configuration Management
- [x] Generate per-node config files (ILP address, keys)
- [x] Configure BNL/KNL for peer discovery
- [x] Set up routing fees per node
- [x] Configure settlement layer (simulated)

### 3. Implement AC 1: Docker Compose Infrastructure
- [ ] Test: Start 5-node stack
- [ ] Test: Verify container health checks
- [ ] Test: Ping test (inter-node connectivity)

### 4. Implement AC 2: ILP STREAM Connection
- [ ] Test: Establish connection between 2 nodes
- [ ] Test: Verify encrypted STREAM
- [ ] Test: Heartbeat monitoring

### 5. Implement AC 3: Multi-Hop Payment
- [ ] Test: 5-hop payment (Node 0 → 4)
- [ ] Test: Verify internal ledger updates
- [ ] Test: Latency measurement

### 6. Implement AC 4: BTP-NIPs Over ILP STREAM
- [ ] Integrate BTP-NIPs packet serialization with Dassie
- [ ] Test: Send EVENT message
- [ ] Test: Verify end-to-end flow

### 7. Implement AC 5: Peer Discovery
- [ ] Configure BNL/KNL
- [ ] Test: Full mesh formation
- [ ] Test: Routing table verification

### 8. Implement AC 6: Settlement
- [ ] Implement simulated settlement layer
- [ ] Test: Automatic settlement trigger
- [ ] Test: Balance verification

### 9. Implement AC 7: Resource Monitoring
- [ ] Set Docker resource limits
- [ ] Monitor `docker stats`
- [ ] Verify compliance with limits

### 10. Implement AC 8: Failover
- [ ] Test: Container restart
- [ ] Test: Reconnection
- [ ] Test: Payment recovery

### 11. Implement AC 9: Network Constraints
- [ ] Use `tc` for latency/packet loss simulation
- [ ] Test: Performance degradation
- [ ] Test: Retry behavior

### 12. Implement AC 10: CI/CD Integration
- [ ] Add Dassie tests to GitHub Actions
- [ ] Configure Docker-in-Docker
- [ ] Optimize for CI speed

### 13. Documentation
- [ ] Docker setup guide
- [ ] Dassie configuration reference
- [ ] Troubleshooting guide

---

## Dev Notes

### Prerequisites from Story 11.1

**Required API from `createTestNetwork()`:**

Story 11.4 depends on the test framework from Story 11.1. The framework provides:

```typescript
// Framework API (from packages/app-nostream/test/btp-nips/n-peer/framework.ts)
interface TestNetworkConfig {
  nodeCount: number;
  enablePeerDiscovery?: boolean;
  networkTopology?: 'mesh' | 'star' | 'ring';
  networkSimulation?: {
    latency?: number;      // Simulated network delay (ms)
    jitter?: number;       // ±jitter (ms)
    packetLoss?: number;   // Packet loss rate (0.0-1.0)
  };
  // NEW for Story 11.4:
  executionMode?: 'in-process' | 'docker';  // Docker execution mode
  dockerCompose?: string;                   // Path to docker-compose.yml
  dassieNodes?: boolean;                    // Use real Dassie instead of mocks
}

interface TestNode {
  id: string;
  ilpAddress: string;
  pubkey: string;
  privkey: Buffer;
  repository: EventRepository;
  cache: EventCache;
  subscriptionManager: SubscriptionManager;
  peerDiscovery: PeerDiscoveryService;
  streamConnection: MockStreamConnection | RealDassieConnection;  // Now supports real Dassie

  // Helper methods
  publishEvent(event: NostrEvent): Promise<void>;
  subscribe(filters: NostrFilter[]): Promise<string>;
  getReceivedEvents(eventId?: string): NostrEvent[];

  // NEW for Dassie integration:
  getPeers(): Promise<PeerInfo[]>;
  sendILPPayment(opts: PaymentOpts): Promise<Payment>;
  getInternalLedger(): Promise<LedgerState>;
}

// Usage:
const nodes = await createTestNetwork(5, {
  executionMode: 'docker',
  dockerCompose: './test/docker/dassie-stack.yml',
  dassieNodes: true
});
```

**Blocker Check:** Verify Story 11.1 status is "Done" before starting implementation.

### File Structure

**New Files to Create:**

```
packages/app-nostream/test/docker/
├── dassie-stack.yml              # Docker Compose for N Dassie nodes
├── config/
│   ├── node-0.json              # Dassie config for node 0
│   ├── node-1.json              # Dassie config for node 1
│   ├── node-2.json              # Dassie config for node 2
│   ├── node-3.json              # Dassie config for node 3
│   └── node-4.json              # Dassie config for node 4
└── scripts/
    ├── wait-for-health.sh       # Health check utility
    └── init-postgres.sql        # DB initialization

packages/app-nostream/test/btp-nips/integration/
└── dassie-integration.spec.ts   # Main test suite (AC 1-10)

docker/dassie/
└── Dockerfile                   # Dassie container image
```

**Modified Files:**
- `packages/app-nostream/test/btp-nips/n-peer/framework.ts` - Add Docker execution mode support
- `packages/app-nostream/test/btp-nips/n-peer/test-node.ts` - Add RealDassieConnection interface

### BTP-NIPs + Dassie Integration

**Existing Implementation (Epic 5):**

BTP-NIPs packet serialization is already implemented:
- Parser: `packages/app-nostream/src/btp-nips/parser.ts`
- Message types: EVENT, REQ, CLOSE, EOSE, OK

```typescript
// From packages/app-nostream/src/btp-nips/parser.ts
export function serializeEventMessage(event: NostrEvent): Buffer {
  // Serializes Nostr event into BTP-NIPs packet format
  // Returns: [version][messageType][payloadLength][JSON payload]
}

export function parse(buffer: Buffer): BTPNIPsPacket {
  // Parses BTP-NIPs packet
  // Returns: { header, payload: { payment, nostr, metadata } }
}
```

**Integration with Dassie ILP STREAM:**

Dassie provides tRPC API for ILP operations (from Story 2.x):
- RPC endpoint: `ws://dassie:7768/trpc`
- Methods: `ilp.sendPacket({ destination, data })`

**Test Flow (AC 4):**
1. Serialize Nostr event using `serializeEventMessage(event)`
2. Send via Dassie tRPC: `dassieClient.ilp.sendPacket({ destination: node1.ilpAddress, data: serialized })`
3. Node 1 receives via ILP STREAM, deserializes using `parse(data)`
4. Verify event stored in Node 1's PostgreSQL
5. Node 1 sends ILP FULFILL back

**Maximum Packet Size:** 32KB (ILP PREPARE limit per ILP RFC)

### Dassie Configuration

**Dassie Heartbeat Intervals (Verified from Source):**

From `packages/app-dassie/src/peer-protocol/constants/timings.ts`:
- `MIN_HEARTBEAT_INTERVAL = 5000` (5 seconds)
- `MAX_HEARTBEAT_INTERVAL = 20_000` (20 seconds)
- Actual interval varies between 5-20 seconds (not fixed at 10)

**Config Schema (node-0.json example):**

```json
{
  "nodeId": "0",
  "ilpAddress": "g.dassie.node0",
  "rpc": {
    "port": 7768,
    "authToken": "test-token-node0"
  },
  "database": {
    "host": "postgres",
    "port": 5432,
    "database": "dassie_node0",
    "user": "test",
    "password": "test"
  },
  "redis": {
    "host": "redis",
    "port": 6379
  },
  "settlement": {
    "scheme": "mock",
    "autoSettle": true,
    "threshold": 10000
  },
  "peers": {
    "bootstrap": ["http://dassie-node-1:7768"]
  }
}
```

### Simulated Settlement Layer

**Implementation:**

Use in-memory settlement simulator instead of real blockchain:

```typescript
// Mock settlement module for Dassie config
class MockSettlementLayer {
  private balances = new Map<string, number>();

  async settle(from: string, to: string, amount: number) {
    // Instant settlement (no blockchain latency)
    this.balances.set(from, (this.balances.get(from) || 0) - amount);
    this.balances.set(to, (this.balances.get(to) || 0) + amount);
    console.log(`Settlement: ${from} → ${to}: ${amount} msats`);
  }

  async getBalance(address: string): Promise<number> {
    return this.balances.get(address) || 0;
  }
}
```

**Dassie Configuration (settlement section):**
```json
{
  "settlement": {
    "scheme": "mock",           // Use mock instead of real blockchain
    "autoSettle": true,         // Automatically trigger settlement
    "threshold": 10000,         // Settle when balance exceeds 10,000 msats
    "instant": true             // No blockchain delay simulation
  }
}
```

**Verification (AC 6):**
- Settlement triggered when node balance > threshold
- Balances updated instantly (< 5 seconds)
- All nodes maintain balanced ledgers (conservation of value)

### Performance Target Rationale

**Latency Targets:**

Based on Docker local network characteristics:
- Docker bridge network: ~1-5ms base latency
- ILP STREAM overhead: ~10-20ms per hop (serialization + routing)
- 5-hop payment: 5 × 20ms = 100ms theoretical, **500ms p95 with buffer**

**Timeout Configuration:**
- Health check timeout: 30 seconds (Docker container startup)
- Reconnection timeout: 15 seconds (AC 8)
- CI test timeout: 15 minutes (AC 10, Tier 2 budget)

**CI Environment Degradation:**

If CI performance is insufficient, tests can run with relaxed targets:
- **Dev environment:** Strict targets (500ms p95)
- **CI environment:** Relaxed targets (2000ms p95, 4x buffer)

**Environment Detection:**
```typescript
const isCI = process.env.CI === 'true';
const latencyTarget = isCI ? 2000 : 500;  // Relaxed in CI
```

### Testing

**Test Location:**
- `packages/app-nostream/test/btp-nips/integration/dassie-integration.spec.ts`

**Testing Framework:**
- **Vitest** for test execution
- **Testcontainers** for Docker orchestration (extends Story 11.1 framework)
- **docker-compose** for multi-node Dassie stack

**Testing Patterns:**
- Docker Compose stack startup/teardown
- Real Dassie node integration (no mocks for ILP layer)
- Health check verification before test execution
- Resource cleanup after each test
- Performance metric collection

**Test Structure:**
```typescript
describe('AC 1: Docker Compose Infrastructure', () => {
  it('should start 5-node Dassie stack', async () => {
    const nodes = await createTestNetwork(5, {
      executionMode: 'docker',
      dockerCompose: './test/docker/dassie-stack.yml',
      dassieNodes: true
    });

    // Verify all containers healthy
    await waitForContainersHealthy(nodes, 30000);

    // Verify inter-node connectivity
    for (const node of nodes) {
      const health = await node.healthCheck();
      expect(health.status).toBe('healthy');
    }
  });
});
```

**CI/CD Integration:**
- Tests run in GitHub Actions with Docker-in-Docker
- 15-minute timeout for Tier 2 tests
- Docker logs published as artifacts on failure
- Automatic cleanup on test completion

**Resource Constraints:**
- Per-node memory limit: 512MB
- Per-node CPU limit: 0.5 cores
- Total test resource budget: 8GB RAM (10 nodes × 512MB + overhead)

### Troubleshooting Guide

**Common Issues and Solutions:**

**1. Docker Containers Fail Health Check:**
- **Symptom:** Containers stuck in "starting" state
- **Solution:**
  - Increase health check timeout in docker-compose.yml (`start_period: 60s`)
  - Check PostgreSQL/Redis ready before Dassie starts (depends_on with health checks)
  - Verify Dassie config.json syntax: `cat config/node-0.json | jq`

**2. ILP Connection Fails:**
- **Symptom:** "Connection refused" or "ECONNRESET" errors
- **Solution:**
  - Verify static IPs in docker-compose.yml match config files
  - Check Docker network isolation: `docker network inspect n-peer-test`
  - Enable Dassie debug logging: `DASSIE_LOG_LEVEL=debug`
  - Verify firewall rules: `docker exec dassie-node-0 ping dassie-node-1`

**3. Tests Flaky in CI:**
- **Symptom:** Tests pass locally but fail in CI
- **Solution:**
  - Increase timeout buffers (CI has variable performance)
  - Use `waitForContainersHealthy()` with generous timeout (60s in CI vs 30s local)
  - Retry failed network operations with exponential backoff
  - Enable CI environment detection: `const isCI = process.env.CI === 'true'`

**4. Resource Limits Exceeded:**
- **Symptom:** Docker "OOMKilled" or performance degradation
- **Solution:**
  - Reduce node count (5 instead of 10 for faster tests)
  - Use Docker memory limits: `mem_limit: 512m` in docker-compose.yml
  - Profile memory usage: `docker stats --no-stream`
  - Check for leaks: `docker logs dassie-node-0 | grep "memory"`

**5. PostgreSQL Migration Failures:**
- **Symptom:** "relation does not exist" errors
- **Solution:**
  - Ensure migration runs before tests: `docker-compose run --rm nostream-migrate`
  - Check migration logs: `docker logs nostream-migrate`
  - Verify DB connection: `docker exec postgres psql -U test -d dassie_node0 -c '\dt'`

**6. Port Conflicts:**
- **Symptom:** "port already in use" errors
- **Solution:**
  - Check for existing containers: `docker ps -a`
  - Clean up: `docker-compose down -v --remove-orphans`
  - Use dynamic port mapping in tests (avoid hardcoding 7768, 5432, etc.)

### Execution Mode: Docker Containers

```typescript
// Create 5-node network with real Dassie
const nodes = await createTestNetwork(5, {
  executionMode: 'docker',
  dockerCompose: './test/docker/dassie-stack.yml',
  dassieNodes: true,
  networkSimulation: {
    latency: 10,        // Simulated 10ms inter-node latency
    packetLoss: 0.001   // 0.1% packet loss
  }
});

// Each node is a Docker container running Dassie
// Network calls are real TCP over Docker network
```

### Docker Compose Example

```yaml
version: '3.8'

services:
  dassie-node-0:
    build: ./docker/dassie
    container_name: dassie-node-0
    networks:
      n-peer:
        ipv4_address: 172.20.0.10
    environment:
      - ILP_ADDRESS=g.dassie.node0
      - NODE_ID=0
      - DB_HOST=postgres
      - REDIS_HOST=redis
    volumes:
      - ./config/node-0.json:/app/config.json:ro
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 5s
      timeout: 3s
      retries: 3
    depends_on:
      - postgres
      - redis

  postgres:
    image: postgres:16
    networks:
      - n-peer
    environment:
      - POSTGRES_DB=nostream
      - POSTGRES_USER=test
      - POSTGRES_PASSWORD=test

  redis:
    image: redis:7
    networks:
      - n-peer

networks:
  n-peer:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
```

### Test Pattern with Docker

```typescript
describe('AC 3: Multi-Hop Payment', () => {
  it('should route payment through Docker Dassie network', async () => {
    // 1. Start Docker stack
    const nodes = await createTestNetwork(5, {
      executionMode: 'docker',
      dockerCompose: './test/docker/dassie-stack.yml'
    });

    // Wait for all nodes healthy
    await waitForContainersHealthy(nodes, 30000);

    // 2. Verify peer connections
    for (const node of nodes) {
      const peers = await node.getPeers();
      expect(peers.length).toBe(4);  // Full mesh: 4 peers each
    }

    // 3. Send payment from Node 0 to Node 4
    const payment = await nodes[0].sendILPPayment({
      destination: nodes[4].ilpAddress,
      amount: '100',
      currency: 'msat'
    });

    // 4. Wait for fulfillment
    await payment.waitForFulfillment(5000);

    expect(payment.status).toBe('fulfilled');
    expect(payment.hops).toBe(5);  // 0 → 1 → 2 → 3 → 4

    // 5. Verify internal ledger
    const node4Ledger = await nodes[4].getInternalLedger();
    expect(node4Ledger.balance).toBe(50);  // Received 50 msats after fees

    // 6. Cleanup
    await cleanupDockerNetwork(nodes);
  });
});
```

### Performance Targets

- Connection establishment: < 2 seconds
- 5-hop payment: < 500ms (p95)
- Network failover: < 15 seconds
- Docker startup: < 60 seconds

### CI/CD Workflow Example

**GitHub Actions Configuration:**

Create `.github/workflows/dassie-integration.yml`:

```yaml
name: Dassie Integration Tests

on:
  pull_request:
    paths:
      - 'packages/app-nostream/**'
      - 'packages/app-dassie/**'
      - 'docker/**'
      - '.github/workflows/dassie-integration.yml'

jobs:
  dassie-integration:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'pnpm'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build Dassie image
        run: docker build -f docker/Dockerfile.dassie -t dassie:test .

      - name: Build Nostream image (for shared services)
        run: docker build -f docker/Dockerfile.nostream -t nostream:test .

      - name: Run Dassie integration tests
        env:
          CI: true
        run: pnpm --filter @nostream-ilp/app-nostream test:dassie-integration

      - name: Upload Docker logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: docker-logs
          path: |
            /tmp/dassie-node-*.log
            /tmp/docker-compose-*.log
          retention-days: 7

      - name: Clean up Docker resources
        if: always()
        run: |
          docker-compose -f packages/app-nostream/test/docker/dassie-stack.yml down -v --remove-orphans || true
          docker system prune -f
```

**package.json script (packages/app-nostream):**

```json
{
  "scripts": {
    "test:dassie-integration": "vitest run test/btp-nips/integration/dassie-integration.spec.ts --reporter=verbose"
  }
}
```

**Test Configuration (vitest.config.ts):**

```typescript
export default defineConfig({
  test: {
    testTimeout: 120000,  // 2 minutes per test (Docker startup is slow)
    hookTimeout: 60000,   // 1 minute for beforeEach/afterEach
  }
});
```

---

## Dev Agent Record

### Agent Model Used
- Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
- None required for this story

### Completion Notes

**Implementation Status:**
- ✅ Docker Compose infrastructure complete (5-node stack with PostgreSQL/Redis)
- ✅ Node configuration files created for all 5 nodes (BNL/KNL, routing, settlement)
- ✅ Test framework extended to support Docker execution mode
- ✅ Integration test suite written for all 10 Acceptance Criteria
- ⚠️ **Partial:** Tests written but not fully executable yet due to missing Dassie tRPC endpoints

**Known Limitations:**
1. **Dassie tRPC Endpoints:** The test framework calls tRPC endpoints (peers.list, ilp.sendPayment, ledger.getState) that need to be implemented in the Dassie application
2. **BTP-NIPs Integration:** AC 4 (BTP-NIPs over ILP STREAM) requires integration work in Dassie to handle BTP-NIPs packets
3. **Docker Network Simulation:** AC 9 (network constraints with `tc` command) not fully implemented in Docker Compose

**What Works:**
- Docker Compose stack starts successfully with all health checks
- Static IP addressing configured (172.20.0.10-14)
- Framework can create test networks in both `in-process` and `docker` modes
- Mock tests pass successfully
- Type-safe interfaces for real Dassie integration

**Next Steps:**
1. Implement missing Dassie tRPC endpoints:
   - `peers.list` - Return peer information
   - `peers.count` - Return active peer count
   - `ilp.sendPayment` - Send ILP payment
   - `ilp.getPaymentStatus` - Check payment status
   - `ledger.getState` - Return internal ledger state
2. Configure Dassie to load from config.json file
3. Integrate BTP-NIPs packet handling in Dassie
4. Add `tc` (traffic control) commands to Docker Compose for network simulation

### File List

**Created:**
- packages/app-nostream/test/docker/dassie-stack.yml
- packages/app-nostream/test/docker/config/node-0.json
- packages/app-nostream/test/docker/config/node-1.json
- packages/app-nostream/test/docker/config/node-2.json
- packages/app-nostream/test/docker/config/node-3.json
- packages/app-nostream/test/docker/config/node-4.json
- packages/app-nostream/test/docker/scripts/init-postgres.sql
- packages/app-nostream/test/docker/scripts/wait-for-health.sh
- packages/app-nostream/test/btp-nips/integration/dassie-integration.spec.ts

**Modified:**
- packages/app-nostream/test/btp-nips/n-peer/config.ts (added Docker execution mode types)
- packages/app-nostream/test/btp-nips/n-peer/test-node.ts (added RealDassieConnection interface)
- packages/app-nostream/test/btp-nips/n-peer/framework.ts (added Docker orchestration)
- packages/app-nostream/test/btp-nips/n-peer/monitoring.ts (fixed async connection count handling)

---

## Definition of Done

- ✅ All 10 acceptance criteria met
- ✅ Real Dassie nodes integrated (no mocks in critical path)
- ✅ Docker Compose stack working
- ✅ Multi-hop payments verified with real ILP routing
- ✅ CI/CD integration complete
- ✅ Documentation complete
- ✅ Code reviewed and approved

---

## QA Results

*(To be populated by Quinn)*

**Docker Integration:**
- [ ] Docker stack starts: ☐ PASS ☐ FAIL
- [ ] ILP payments work: ☐ PASS ☐ FAIL
- [ ] CI/CD compatible: ☐ PASS ☐ FAIL

**Recommendation:** ☐ PASS ☐ PASS with CONCERNS ☐ FAIL

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-16 | 1.0 | Initial detailed story creation | Sarah (PO) |
| 2025-12-16 | 1.1 | Validation fixes: Added Testing subsection, Prerequisites from Story 11.1, File Structure, BTP-NIPs integration details, Dassie configuration (verified against source), Simulated settlement implementation, Performance target rationale, Troubleshooting guide, CI/CD workflow, Dev Agent Record section (empty), References section; Fixed AC 2 heartbeat interval (5-20s verified from Dassie source) | Claude (Validator) |
| 2025-12-16 | 1.2 | Implementation: Docker infrastructure complete (Tasks 1-2), test framework extended for Docker mode (Task 3), integration test suite created for all 10 ACs. Pending: Dassie tRPC endpoint implementation, BTP-NIPs integration, network simulation. | James (Dev Agent) |

---

## References

**Project Documentation:**
- Epic 11: `docs/prd/epic-11-btp-nips-n-peer-verification.md`
- Story 11.1: `docs/stories/11.1.story.md` (Test Framework)
- CLAUDE.md: Dassie Architecture (lines 199-276)
- Tech Stack: `docs/architecture/tech-stack.md`
- Source Tree: `docs/architecture/source-tree-structure.md`

**Source Code:**
- BTP-NIPs Parser: `packages/app-nostream/src/btp-nips/parser.ts`
- Dassie Heartbeat: `packages/app-dassie/src/peer-protocol/send-heartbeats.ts`
- Dassie Timings: `packages/app-dassie/src/peer-protocol/constants/timings.ts`
- Test Framework: `packages/app-nostream/test/btp-nips/n-peer/framework.ts`

**External Documentation:**
- Dassie Repository: https://github.com/justmoon/dassie
- ILP STREAM RFC: https://interledger.org/rfcs/0029-stream/
- Docker Compose Docs: https://docs.docker.com/compose/
- Testcontainers: https://testcontainers.com/
- Vitest: https://vitest.dev/
- GitHub Actions: https://docs.github.com/en/actions
