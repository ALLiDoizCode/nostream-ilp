# Story 5.10: Dassie Configuration & BTP-NIPs Reception

**Epic:** 5 - BTP-NIPs Core Protocol
**Status:** Draft
**Priority:** High (Blocker for Story 11.4)
**Estimated Effort:** 4 days
**Created:** 2025-12-16
**Dependencies:** Story 5.9 (Dassie tRPC Endpoints)

---

## Story

**As a** Dassie node operator,
**I want** Dassie to load configuration from config.json and receive BTP-NIPs packets via ILP STREAM,
**so that** Dassie nodes can participate in the BTP-NIPs network and handle Nostr events over ILP.

---

## Acceptance Criteria

### AC 1: Configuration Loading from config.json

**Given** Dassie node starts with a config.json file present
**When** the node initializes
**Then** the node should:
- ✅ Load configuration from the specified config.json path
- ✅ Parse JSON and validate required fields (nodeId, ilpAddress, rpc, settlement, peers)
- ✅ Apply configuration to node components (RPC server, peer manager, settlement)
- ✅ Log configuration summary on startup
- ✅ Exit with error if config.json is missing or invalid

**Example config.json:**
```json
{
  "nodeId": "0",
  "ilpAddress": "g.dassie.node0",
  "rpc": {
    "port": 7768,
    "authToken": "test-token-node0"
  },
  "settlement": {
    "scheme": "mock",
    "autoSettle": true,
    "threshold": 10000
  },
  "peers": {
    "bootstrap": ["g.dassie.node1", "g.dassie.node2"]
  }
}
```

### AC 2: BTP-NIPs Packet Reception via ILP STREAM

**Given** Dassie node receives an ILP STREAM packet
**When** the packet contains BTP-NIPs data (type: 'btp-nips')
**Then** the node should:
- ✅ Detect BTP-NIPs packet type from STREAM metadata
- ✅ Extract BTP-NIPs payload from ILP packet data
- ✅ Preserve ILP fulfillment conditions for response
- ✅ Route packet to BTP-NIPs handler
- ✅ Response time < 100ms for packet routing

**ILP STREAM Packet Structure:**
```typescript
{
  ilpPacket: {
    type: 'prepare',
    amount: '1000',
    executionCondition: Buffer,
    destination: 'g.dassie.node1',
    data: Buffer // Contains BTP-NIPs payload
  },
  streamMetadata: {
    type: 'btp-nips', // Custom STREAM application type
    version: 1
  }
}
```

### AC 3: BTP-NIPs Packet Deserialization

**Given** BTP-NIPs payload extracted from ILP packet
**When** deserializing the payload
**Then** the node should:
- ✅ Parse BTP-NIPs packet format (type, subId, payload)
- ✅ Validate packet structure matches specification
- ✅ Deserialize inner Nostr event or filter JSON
- ✅ Verify Nostr event signatures if present
- ✅ Reject malformed packets with appropriate error

**BTP-NIPs Packet Format:**
```typescript
{
  type: 'EVENT' | 'REQ' | 'CLOSE',
  subId?: string,
  payload: NostrEvent | NostrFilter[]
}
```

### AC 4: Packet Routing to Handlers

**Given** deserialized BTP-NIPs packet with type
**When** routing to appropriate handler
**Then** the node should:
- ✅ Route EVENT packets to event handler
- ✅ Route REQ packets to subscription handler
- ✅ Route CLOSE packets to close handler
- ✅ Maintain handler registry for extensibility
- ✅ Pass ILP context (sender, amount, condition) to handlers

**Handler Interface:**
```typescript
interface BtpNipsHandler {
  type: 'EVENT' | 'REQ' | 'CLOSE';
  handle(
    packet: BtpNipsPacket,
    ilpContext: IlpContext
  ): Promise<BtpNipsResponse>;
}
```

### AC 5: ILP Fulfillment/Rejection

**Given** BTP-NIPs handler processes packet
**When** handler completes processing
**Then** the node should:
- ✅ Send ILP fulfillment if packet processed successfully
- ✅ Include BTP-NIPs response in ILP fulfillment data
- ✅ Send ILP rejection if packet processing failed
- ✅ Include error message in rejection data
- ✅ Ensure ILP condition/fulfillment cryptographic validity

**ILP Fulfillment:**
```typescript
{
  fulfillment: Buffer, // SHA-256 preimage of condition
  data: Buffer // BTP-NIPs response: ["OK", eventId, true, ""] or ["EOSE", subId]
}
```

**ILP Rejection:**
```typescript
{
  code: 'F99', // Temporary failure
  message: 'Invalid Nostr event signature',
  data: Buffer // BTP-NIPs error response
}
```

### AC 6: Event Handler Implementation

**Given** EVENT packet received
**When** processing the event
**Then** the handler should:
- ✅ Verify Nostr event signature
- ✅ Check event against relay policies (if applicable)
- ✅ Store event in local event repository
- ✅ Propagate event to subscribed peers
- ✅ Return OK response with acceptance status

**Event Handler Flow:**
```
EVENT packet → Verify signature → Check policies → Store → Propagate → OK response
```

### AC 7: Subscription Handler Implementation

**Given** REQ packet received with filters
**When** processing the subscription
**Then** the handler should:
- ✅ Parse Nostr filters from packet
- ✅ Register subscription with subscription manager
- ✅ Query matching events from repository
- ✅ Send matching events to requester via ILP
- ✅ Send EOSE when initial query complete

**Subscription Handler Flow:**
```
REQ packet → Parse filters → Register subscription → Query events → Send events → EOSE
```

### AC 8: Error Handling & Logging

**Given** various error conditions during packet processing
**When** errors occur
**Then** the node should:
- ✅ Log all packet processing errors with context
- ✅ Return structured error responses to sender
- ✅ Increment error metrics for monitoring
- ✅ Gracefully handle malformed packets without crashing
- ✅ Rate limit error responses to prevent abuse

---

## Tasks/Subtasks

- [ ] Task 1: Configuration System (AC: 1)
  - [ ] Create file: `packages/app-dassie/src/backend/config/loader.ts`
  - [ ] Implement `loadConfigFromFile(path: string): Promise<DassieConfig>`
  - [ ] Add JSON schema validation for config structure
  - [ ] Add environment variable override support (e.g., `DASSIE_CONFIG_PATH`)
  - [ ] Add unit tests for config loading

- [ ] Task 2: BTP-NIPs Packet Detection (AC: 2)
  - [ ] Modify ILP STREAM handler to detect BTP-NIPs packets
  - [ ] Check STREAM metadata for `type: 'btp-nips'`
  - [ ] Extract BTP-NIPs payload from ILP packet data
  - [ ] Add unit tests for packet detection

- [ ] Task 3: BTP-NIPs Packet Deserialization (AC: 3)
  - [ ] Create file: `packages/app-dassie/src/backend/btp-nips/parser.ts`
  - [ ] Implement `deserializeBtpNipsPacket(buffer: Buffer): BtpNipsPacket`
  - [ ] Add packet format validation
  - [ ] Add Nostr event signature verification
  - [ ] Add unit tests for deserialization

- [ ] Task 4: Handler Registry (AC: 4)
  - [ ] Create file: `packages/app-dassie/src/backend/btp-nips/handler-registry.ts`
  - [ ] Implement `HandlerRegistry` class with `register()` and `route()` methods
  - [ ] Add default handlers for EVENT, REQ, CLOSE
  - [ ] Add unit tests for routing logic

- [ ] Task 5: Event Handler (AC: 6)
  - [ ] Create file: `packages/app-dassie/src/backend/btp-nips/handlers/event-handler.ts`
  - [ ] Implement event signature verification
  - [ ] Integrate with event repository (SQLite storage)
  - [ ] Add event propagation to subscribed peers
  - [ ] Add unit tests for event handler

- [ ] Task 6: Subscription Handler (AC: 7)
  - [ ] Create file: `packages/app-dassie/src/backend/btp-nips/handlers/req-handler.ts`
  - [ ] Implement filter parsing and validation
  - [ ] Integrate with subscription manager
  - [ ] Add event query and response logic
  - [ ] Add unit tests for subscription handler

- [ ] Task 7: Close Handler (AC: 4)
  - [ ] Create file: `packages/app-dassie/src/backend/btp-nips/handlers/close-handler.ts`
  - [ ] Implement subscription cleanup logic
  - [ ] Add unit tests for close handler

- [ ] Task 8: ILP Fulfillment/Rejection (AC: 5)
  - [ ] Implement `createFulfillment(response: BtpNipsResponse): IlpFulfillment`
  - [ ] Implement `createRejection(error: Error): IlpRejection`
  - [ ] Verify cryptographic validity of condition/fulfillment
  - [ ] Add unit tests for fulfillment/rejection

- [ ] Task 9: Error Handling (AC: 8)
  - [ ] Add error logging with structured context
  - [ ] Implement error metrics (Prometheus counters)
  - [ ] Add rate limiting for error responses
  - [ ] Add integration tests for error scenarios

- [ ] Task 10: Integration Testing (AC: All)
  - [ ] Test config loading with valid/invalid configs
  - [ ] Test BTP-NIPs packet flow end-to-end
  - [ ] Test all packet types (EVENT, REQ, CLOSE)
  - [ ] Test ILP fulfillment/rejection responses
  - [ ] Test error handling scenarios

- [ ] Task 11: Documentation (AC: All)
  - [ ] Add JSDoc comments to all modules
  - [ ] Document config.json format and options
  - [ ] Add BTP-NIPs packet format specification
  - [ ] Update Dassie README with BTP-NIPs integration

---

## Dev Notes

### Architecture Context

**Dassie Project Structure:**

From the monorepo structure [Source: docs/architecture/source-tree-structure.md]:
- Dassie backend code: `packages/app-dassie/src/backend/`
- ILP STREAM handler: `packages/app-dassie/src/backend/ilp/stream.ts`
- Peer manager: `packages/app-dassie/src/backend/peers/peer-manager.ts`

**Integration Point:**

BTP-NIPs packets are embedded in ILP STREAM packets. The flow is:
1. ILP packet arrives at Dassie node
2. STREAM handler detects `type: 'btp-nips'` in metadata
3. Extracts BTP-NIPs payload from packet data
4. Routes to BTP-NIPs handler registry
5. Handler processes packet (verify, store, propagate)
6. Returns ILP fulfillment or rejection

### Configuration Format

**config.json Schema:**

```typescript
interface DassieConfig {
  nodeId: string;           // Unique node identifier
  ilpAddress: string;       // ILP address (e.g., "g.dassie.node0")

  rpc: {
    port: number;           // tRPC server port (default: 7768)
    authToken: string;      // Bearer token for authentication
  };

  settlement: {
    scheme: 'mock' | 'lightning' | 'on-chain';
    autoSettle: boolean;    // Automatically settle when threshold reached
    threshold: number;      // Settlement threshold in base units (msats)
  };

  peers: {
    bootstrap: string[];    // Bootstrap Node List (BNL)
    maxPeers?: number;      // Maximum peer connections (default: 10)
  };

  btpNips?: {
    enabled: boolean;       // Enable BTP-NIPs packet handling (default: true)
    maxEventSize?: number;  // Max event size in bytes (default: 65536)
  };
}
```

**Environment Variable Overrides:**
- `DASSIE_CONFIG_PATH`: Path to config.json (default: `./config.json`)
- `DASSIE_NODE_ID`: Override nodeId
- `DASSIE_RPC_PORT`: Override RPC port
- `DASSIE_RPC_AUTH_TOKEN`: Override auth token

### BTP-NIPs Packet Format

**Packet Structure (OER-encoded):**

```typescript
// BTP-NIPs packet format (embedded in ILP STREAM data)
interface BtpNipsPacket {
  type: 'EVENT' | 'REQ' | 'CLOSE';  // Packet type
  subId?: string;                    // Subscription ID (for REQ/CLOSE)
  payload: Buffer;                   // Serialized Nostr event or filters
}

// EVENT packet payload: NostrEvent (JSON)
{
  id: string,
  pubkey: string,
  created_at: number,
  kind: number,
  tags: string[][],
  content: string,
  sig: string
}

// REQ packet payload: NostrFilter[] (JSON)
[
  { kinds: [1], authors: ["pubkey..."], limit: 10 },
  { kinds: [3], "#p": ["pubkey..."] }
]

// CLOSE packet: no payload (just subId)
```

**Serialization:**
- Use `@dassie/lib-oer` for outer BTP-NIPs packet encoding
- Use JSON for inner Nostr event/filter encoding
- Total packet size limit: 64 KB (configurable)

### ILP STREAM Integration

**STREAM Packet Metadata:**

```typescript
// ILP STREAM packet with BTP-NIPs metadata
{
  ilpPacket: {
    type: 'prepare',
    amount: '1000',                    // Payment amount in msats
    executionCondition: Buffer,        // SHA-256 hash of fulfillment
    expiresAt: Date,
    destination: 'g.dassie.node1',
    data: Buffer                       // BTP-NIPs packet (OER-encoded)
  },
  streamMetadata: {
    type: 'btp-nips',                  // Custom application type
    version: 1,
    subprotocol: 'nostr'
  }
}
```

**Fulfillment Response:**

```typescript
{
  fulfillment: Buffer,                 // SHA-256 preimage
  data: Buffer                         // BTP-NIPs response (OER-encoded)
}

// BTP-NIPs response formats (NIP-01):
["OK", eventId, true, ""]              // Event accepted
["OK", eventId, false, "duplicate"]    // Event rejected
["EOSE", subId]                        // End of stored events
["EVENT", subId, event]                // Event matching subscription
```

### Event Storage

**SQLite Schema (Dassie Internal Ledger):**

Dassie already has an SQLite-based internal ledger. We'll extend it with a `nostr_events` table:

```sql
CREATE TABLE nostr_events (
  id TEXT PRIMARY KEY,               -- Event ID (hex)
  pubkey TEXT NOT NULL,              -- Author pubkey (hex)
  created_at INTEGER NOT NULL,       -- Unix timestamp
  kind INTEGER NOT NULL,             -- Event kind
  tags TEXT NOT NULL,                -- JSON array of tags
  content TEXT NOT NULL,             -- Event content
  sig TEXT NOT NULL,                 -- Signature (hex)
  received_at INTEGER NOT NULL,      -- When we received it
  source_peer TEXT NOT NULL          -- Which peer sent it (ILP address)
);

CREATE INDEX idx_nostr_events_pubkey ON nostr_events(pubkey);
CREATE INDEX idx_nostr_events_kind ON nostr_events(kind);
CREATE INDEX idx_nostr_events_created_at ON nostr_events(created_at);
```

### Handler Architecture

**Handler Interface:**

```typescript
// BTP-NIPs handler interface
export interface BtpNipsHandler {
  type: 'EVENT' | 'REQ' | 'CLOSE';

  handle(
    packet: BtpNipsPacket,
    ilpContext: IlpContext
  ): Promise<BtpNipsResponse>;
}

// ILP context passed to handlers
interface IlpContext {
  sender: string;          // ILP address of sender
  amount: string;          // Payment amount in msats
  condition: Buffer;       // Execution condition
  fulfillment?: Buffer;    // Fulfillment preimage (if already computed)
}

// BTP-NIPs response (will be OER-encoded in ILP fulfillment data)
type BtpNipsResponse =
  | { type: 'OK', eventId: string, accepted: boolean, message: string }
  | { type: 'EOSE', subId: string }
  | { type: 'EVENT', subId: string, event: NostrEvent }
  | { type: 'NOTICE', message: string }
```

**Handler Registry:**

```typescript
export class HandlerRegistry {
  private handlers = new Map<string, BtpNipsHandler>();

  register(handler: BtpNipsHandler): void {
    this.handlers.set(handler.type, handler);
  }

  async route(packet: BtpNipsPacket, ilpContext: IlpContext): Promise<BtpNipsResponse> {
    const handler = this.handlers.get(packet.type);
    if (!handler) {
      throw new Error(`No handler for packet type: ${packet.type}`);
    }
    return await handler.handle(packet, ilpContext);
  }
}
```

### Testing Strategy

**Unit Tests:**
- Config loading with valid/invalid JSON
- BTP-NIPs packet deserialization
- Handler routing logic
- Event signature verification
- Nostr filter matching

**Integration Tests:**
- Full packet flow: ILP STREAM → BTP-NIPs handler → Storage → Response
- Test with real Nostr events from nostr-tools
- Test subscription lifecycle (REQ → EVENT → EOSE → CLOSE)
- Test ILP fulfillment/rejection responses

**Test Tools:**
- Vitest for unit tests
- Mock ILP packets with test fixtures
- Use nostr-tools for event generation and signing

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-16 | 1.0 | Initial story creation for Dassie BTP-NIPs reception | Sarah (PO) |

---

## Dev Agent Record

*(To be populated during implementation)*

### Agent Model Used

### Debug Log References

### Completion Notes

### File List

**Created:**
- (List files created during implementation)

**Modified:**
- (List files modified during implementation)

---

## QA Results

*(To be populated by Quinn)*

**Configuration Testing:**
- [ ] Config loading works with valid config.json: ☐ PASS ☐ FAIL
- [ ] Config validation rejects invalid configs: ☐ PASS ☐ FAIL

**Packet Reception:**
- [ ] BTP-NIPs packets detected correctly: ☐ PASS ☐ FAIL
- [ ] EVENT packets stored and propagated: ☐ PASS ☐ FAIL
- [ ] REQ packets trigger subscriptions: ☐ PASS ☐ FAIL

**ILP Integration:**
- [ ] ILP fulfillments sent for successful processing: ☐ PASS ☐ FAIL
- [ ] ILP rejections sent for errors: ☐ PASS ☐ FAIL

**Recommendation:** ☐ PASS ☐ PASS with CONCERNS ☐ FAIL

---

## References

- **Story 11.4:** Docker Dassie Integration (`docs/stories/11.4.story.md`)
- **Story 5.9:** Dassie tRPC Endpoints (`docs/stories/5.9.story.md`)
- **Dassie Architecture:** CLAUDE.md (ILP STREAM, Internal Ledger)
- **BTP-NIPs Specification:** Epic 5 PRD (`docs/prd/epic-5-btp-nips-core-protocol.md`)
- **NIP-01:** Basic protocol flow (https://github.com/nostr-protocol/nips/blob/master/01.md)
- **Monorepo Structure:** `docs/architecture/source-tree-structure.md`
