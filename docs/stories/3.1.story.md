# Story 3.1: Modify BasePaymentChannel for ERC-20 AKT Support

## Status

Done

## Story

**As a** developer,
**I want** to modify BasePaymentChannel.sol to work with AKT ERC-20 tokens on Cronos,
**so that** I can reuse 95% of existing battle-tested code.

## Acceptance Criteria

1. Create new contract file: `contracts/CronosPaymentChannel.sol` (copy from BasePaymentChannel.sol)
2. Add IERC20 import: `import "@openzeppelin/contracts/token/ERC20/IERC20.sol";`
3. Add token state variable: `IERC20 public immutable aktToken;`
4. Add constructor: `constructor(address _aktTokenAddress) { aktToken = IERC20(_aktTokenAddress); }`
5. Modify `openChannel()`:
   - Add `uint256 amount` parameter
   - Remove `payable` modifier
   - Replace `msg.value` checks with `amount` parameter
   - Add `aktToken.transferFrom(msg.sender, address(this), amount);`
6. Modify `closeChannel()`:
   - Replace `payable(recipient).transfer()` with `aktToken.transfer(recipient, claimAmount)`
   - Replace sender refund with `aktToken.transfer(sender, refundAmount)`
7. Modify `expireChannel()`:
   - Replace `payable(sender).transfer()` with `aktToken.transfer(sender, balance)`
8. All other functions remain unchanged (generateChannelId, _verifyClaimSignature, getChannel, etc.)
9. Contract compiles successfully
10. Code changes documented in PR

## Tasks / Subtasks

- [x] Task 1: Set Up Contract Development Environment (AC: 9)
  - [x] Verify Node.js 22.x LTS installed
  - [x] Check if Hardhat project exists at repository root (look for hardhat.config.ts)
  - [x] If no hardhat.config.ts exists, initialize Hardhat project:
    - Run: `npx hardhat init`
    - Choose: "Create a TypeScript project"
    - Install recommended dependencies: Yes
  - [x] Install dependencies: `pnpm install hardhat @nomicfoundation/hardhat-toolbox @openzeppelin/contracts`
  - [x] Update hardhat.config.ts to lock Solidity compiler version to 0.8.20:
    ```typescript
    solidity: {
      version: "0.8.20",  // Lock to specific version
      settings: {
        optimizer: {
          enabled: true,
          runs: 200
        }
      }
    }
    ```
  - [x] Verify contracts/ directory exists (Hardhat creates it automatically)
  - [x] Run initial compilation test: `npx hardhat compile`

- [x] Task 2: Locate or Create BasePaymentChannel.sol Reference (AC: 1)
  - [x] Check if BasePaymentChannel.sol exists in repository (contracts/ directory)
  - [x] If exists, read and understand current implementation
  - [x] If NOT exists, use the complete BasePaymentChannel.sol reference implementation provided in Dev Notes section below (see "BasePaymentChannel.sol Reference Implementation")
  - [x] Document baseline implementation for comparison in Task 10

- [x] Task 3: Create CronosPaymentChannel.sol Contract (AC: 1, 2, 3, 4)
  - [x] Create file: `contracts/CronosPaymentChannel.sol`
  - [x] Copy BasePaymentChannel.sol content (from repository or from Dev Notes reference implementation)
  - [x] Rename contract from `BasePaymentChannel` to `CronosPaymentChannel`
  - [x] Add IERC20 import: `import "@openzeppelin/contracts/token/ERC20/IERC20.sol";`
  - [x] Add state variable: `IERC20 public immutable aktToken;`
  - [x] Add constructor with validation:
    ```solidity
    constructor(address _aktTokenAddress) {
        require(_aktTokenAddress != address(0), "Invalid token address");
        aktToken = IERC20(_aktTokenAddress);
    }
    ```
  - [x] Keep all events and errors unchanged
  - [x] Keep Channel struct unchanged

- [x] Task 4: Modify openChannel() Function (AC: 5)
  - [x] Add `uint256 amount` parameter to function signature
  - [x] Remove `payable` modifier from function
  - [x] Replace `if (msg.value == 0)` with `if (amount == 0)`
  - [x] Add token transfer BEFORE channel creation:
    ```solidity
    aktToken.transferFrom(msg.sender, address(this), amount);
    ```
  - [x] Replace all `msg.value` references with `amount` parameter (in balance assignment, event emission)
  - [x] Keep all validation logic unchanged (recipient check, expiration check)
  - [x] Keep generateChannelId() call unchanged

- [x] Task 5: Modify closeChannel() Function (AC: 6)
  - [x] Replace native ETH transfer to recipient:
    - FROM: `payable(channel.recipient).transfer(claimAmount);`
    - TO: `aktToken.transfer(channel.recipient, claimAmount);`
  - [x] Replace native ETH refund to sender:
    - FROM: `payable(channel.sender).transfer(refundAmount);`
    - TO: `aktToken.transfer(channel.sender, refundAmount);`
  - [x] Keep all validation logic unchanged (signature verification, nonce check, balance check)
  - [x] Keep state updates unchanged (isClosed, highestNonce)
  - [x] Keep event emission unchanged

- [x] Task 6: Modify expireChannel() Function (AC: 7)
  - [x] Replace native ETH refund:
    - FROM: `payable(channel.sender).transfer(channel.balance);`
    - TO: `aktToken.transfer(channel.sender, channel.balance);`
  - [x] Keep expiration validation unchanged
  - [x] Keep state updates unchanged
  - [x] Keep event emission unchanged

- [x] Task 7: Verify Unchanged Functions (AC: 8)
  - [x] Verify `generateChannelId()` remains pure function (no changes needed)
  - [x] Verify `_verifyClaimSignature()` uses ECDSA correctly (no changes needed)
  - [x] Verify `getChannel()` view function unchanged
  - [x] Verify `isChannelOpen()` view function unchanged (if exists)
  - [x] Verify `getChannelBalance()` view function unchanged (if exists)
  - [x] Verify `extendExpiration()` function unchanged (if exists)

- [x] Task 8: Compile and Verify Contract (AC: 9)
  - [x] Run Solidity compilation: `npx hardhat compile`
  - [x] Fix any compilation errors (missing imports, typos, etc.)
  - [x] Verify contract compiles without warnings
  - [x] Check generated artifacts in `artifacts/contracts/CronosPaymentChannel.sol/`
  - [x] Verify ABI is generated correctly

- [x] Task 9: Code Review and Documentation (AC: 10)
  - [x] Add NatSpec comments documenting ERC-20 modifications
  - [x] Document constructor parameter: `@param _aktTokenAddress Address of AKT ERC-20 token on Cronos`
  - [x] Document approval requirement in openChannel() NatSpec:
    ```solidity
    /// @notice Opens a payment channel funded with AKT tokens
    /// @dev Requires prior approval: aktToken.approve(address(this), amount)
    ```
  - [x] Add file-level comment explaining Cronos deployment purpose
  - [x] Create or update `contracts/README.md` documenting contract modifications
  - [x] Document AKT token addresses:
    - Cronos Mainnet: `0x39a65A74Dc5A778Ff93d1765Ea51F57BC49c81B3`
    - Cronos Testnet: Use MockAKT (deployed in Story 3.2)

- [x] Task 10: Create Comparison Documentation (AC: 10)
  - [x] Document side-by-side comparison of BasePaymentChannel vs CronosPaymentChannel
  - [x] List all modified functions with before/after code snippets
  - [x] Document unchanged functions
  - [x] Reference research documentation: `docs/research/cronos-akt-deployment/findings/contract-modifications.md`

## Dev Notes

### Previous Story Context

This is the first story of Epic 3 (AKT Payment Channel Deployment - Cronos). Previous epics completed:

- **Epic 1 (Stories 1.1-1.8):** Nostream relay fork with ILP integration stubs
- **Epic 2 (Stories 2.1-2.9):** Dassie multi-blockchain settlement modules (Lightning, Base L2, Cosmos, XRP) and routing statistics RPC endpoint

**Epic 2 Reference - BasePaymentChannel.sol:**

**IMPORTANT:** Epic 2 Story 2.6 was designed to implement a Base L2 payment channel using Solidity contract `BasePaymentChannel.sol`. However, if this file does not exist in the repository, a complete reference implementation is provided below in the "BasePaymentChannel.sol Reference Implementation" section.

Epic 3 pivots from CosmWasm native deployment to Cronos EVM deployment, enabling 95% code reuse from the Base L2 payment channel pattern.

**File Location for Solidity Contracts:** The `contracts/` directory at repository root (`nostream-ilp/contracts/`) contains all EVM-compatible Solidity contracts for Base L2 and Cronos deployments. This is separate from any CosmWasm contracts which would be in a separate repository. If `contracts/` does not exist, it will be created in Task 1 of this story.

[Source: docs/prd/epic-3-cosmwasm-payment-channel-contract.md, docs/stories/2.9.story.md]

---

### Research Context: Cronos Deployment Decision

**Strategic Pivot (2025-11-28):** After comprehensive research, the project pivoted from CosmWasm native deployment to Cronos EVM deployment for MVP. This decision enables:

- **8x faster development:** 7 hours vs 57 hours for CosmWasm
- **8x cheaper development:** $1,140 vs $8,625
- **60-70% cheaper gas than Base L2:** $0.001 vs $0.003 per channel
- **95% code reuse** from existing BasePaymentChannel.sol
- **Production-ready in 1 week** vs 3 weeks

**Why Cronos?**
- 100% EVM compatible (Solidity 0.8.20+, OpenZeppelin, ecrecover)
- AKT available as ERC-20 token: `0x39a65A74Dc5A778Ff93d1765Ea51F57BC49c81B3` (mainnet)
- Trustless IBC bridge from Akash to Cronos (~$0.01 fee, 1-60 min transfer)
- Recent Cancun/Prague fork (Oct 2025) - latest Ethereum features

**CosmWasm Deferred:** Native CosmWasm deployment considered for future if volume exceeds 100k channels/month (gas savings justify development cost).

[Source: docs/research/cronos-akt-deployment/README.md, docs/research/cronos-akt-deployment/comparisons/cronos-vs-cosmwasm.md]

---

### BasePaymentChannel.sol Reference Implementation

**Purpose:** This section provides a complete, working BasePaymentChannel.sol implementation for native ETH payment channels. If this file does not exist in the repository, use this as the baseline for creating CronosPaymentChannel.sol.

**Complete Contract:**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

/// @title BasePaymentChannel
/// @notice Unidirectional payment channel for micropayments using native ETH
/// @dev Based on state channels pattern with off-chain signed claims
contract BasePaymentChannel is ReentrancyGuard {
    using ECDSA for bytes32;
    using MessageHashUtils for bytes32;

    // Events
    event ChannelOpened(
        bytes32 indexed channelId,
        address indexed sender,
        address indexed recipient,
        uint256 balance,
        uint256 expiration
    );

    event ChannelClosed(
        bytes32 indexed channelId,
        uint256 claimAmount,
        uint256 nonce
    );

    // Errors
    error InvalidRecipient();
    error ChannelExpired();
    error InsufficientBalance();
    error NonceNotMonotonic();
    error InvalidSignature();
    error ChannelAlreadyClosed();
    error ChannelNotExpired();

    // Channel state
    struct Channel {
        address sender;        // Payer's address
        address recipient;     // Payee's address
        uint256 balance;       // Locked ETH amount
        uint256 highestNonce;  // Last verified nonce (prevents replay)
        uint256 expiration;    // Unix timestamp when channel expires
        bool isClosed;         // Channel status flag
    }

    mapping(bytes32 => Channel) public channels;

    /// @notice Opens a new payment channel funded with ETH
    /// @param recipient Address that will receive payments from this channel
    /// @param expiration Unix timestamp after which channel can be expired
    /// @return channelId Unique identifier for the created channel
    function openChannel(
        address recipient,
        uint256 expiration
    ) external payable returns (bytes32 channelId) {
        // Validate inputs
        if (recipient == address(0)) revert InvalidRecipient();
        if (expiration <= block.timestamp) revert ChannelExpired();
        if (msg.value == 0) revert InsufficientBalance();

        // Generate unique channel ID
        channelId = generateChannelId(msg.sender, recipient, block.timestamp);

        // Store channel state
        channels[channelId] = Channel({
            sender: msg.sender,
            recipient: recipient,
            balance: msg.value,
            highestNonce: 0,
            expiration: expiration,
            isClosed: false
        });

        // Emit event
        emit ChannelOpened(
            channelId,
            msg.sender,
            recipient,
            msg.value,
            expiration
        );

        return channelId;
    }

    /// @notice Closes a payment channel with a signed claim from the sender
    /// @param channelId Unique identifier of the channel
    /// @param claimAmount Amount being claimed by recipient
    /// @param nonce Monotonically increasing nonce (must be > highestNonce)
    /// @param signature Sender's signature of (channelId, claimAmount, nonce)
    function closeChannel(
        bytes32 channelId,
        uint256 claimAmount,
        uint256 nonce,
        bytes memory signature
    ) external nonReentrant {
        Channel storage channel = channels[channelId];

        // Validation
        if (channel.isClosed) revert ChannelAlreadyClosed();
        if (block.timestamp > channel.expiration) revert ChannelExpired();

        // Verify signature
        _verifyClaimSignature(
            channelId,
            claimAmount,
            nonce,
            signature,
            channel.sender
        );

        // Validate nonce and amount
        if (nonce <= channel.highestNonce) revert NonceNotMonotonic();
        if (claimAmount > channel.balance) revert InsufficientBalance();

        // Update state
        channel.isClosed = true;
        channel.highestNonce = nonce;

        // Transfer funds to recipient
        payable(channel.recipient).transfer(claimAmount);

        // Refund remaining balance to sender
        uint256 refundAmount = channel.balance - claimAmount;
        if (refundAmount > 0) {
            payable(channel.sender).transfer(refundAmount);
        }

        emit ChannelClosed(channelId, claimAmount, nonce);
    }

    /// @notice Expires a channel after expiration timestamp, refunding sender
    /// @param channelId Unique identifier of the channel
    function expireChannel(bytes32 channelId) external {
        Channel storage channel = channels[channelId];

        // Validation
        if (block.timestamp <= channel.expiration) revert ChannelNotExpired();
        if (channel.isClosed) revert ChannelAlreadyClosed();

        // Mark channel closed
        channel.isClosed = true;

        // Refund full balance to sender
        payable(channel.sender).transfer(channel.balance);

        emit ChannelClosed(channelId, 0, channel.highestNonce);
    }

    /// @notice Generates a unique channel ID from sender, recipient, and timestamp
    /// @param sender Address of the channel sender
    /// @param recipient Address of the channel recipient
    /// @param timestamp Block timestamp when channel is opened
    /// @return Unique channel identifier
    function generateChannelId(
        address sender,
        address recipient,
        uint256 timestamp
    ) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(sender, recipient, timestamp));
    }

    /// @notice Verifies a claim signature matches the expected signer
    /// @param channelId Channel identifier
    /// @param claimAmount Amount being claimed
    /// @param nonce Nonce for this claim
    /// @param signature Signature to verify
    /// @param expectedSigner Address that should have signed
    function _verifyClaimSignature(
        bytes32 channelId,
        uint256 claimAmount,
        uint256 nonce,
        bytes memory signature,
        address expectedSigner
    ) internal pure {
        bytes32 messageHash = keccak256(
            abi.encodePacked(channelId, claimAmount, nonce)
        );
        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
        address recoveredSigner = ethSignedMessageHash.recover(signature);

        if (recoveredSigner != expectedSigner) revert InvalidSignature();
    }

    /// @notice Retrieves channel information
    /// @param channelId Unique identifier of the channel
    /// @return Channel struct with all channel details
    function getChannel(bytes32 channelId) external view returns (Channel memory) {
        return channels[channelId];
    }

    /// @notice Checks if a channel is currently open
    /// @param channelId Unique identifier of the channel
    /// @return True if channel exists and is not closed
    function isChannelOpen(bytes32 channelId) external view returns (bool) {
        return !channels[channelId].isClosed && channels[channelId].sender != address(0);
    }

    /// @notice Gets the current balance of a channel
    /// @param channelId Unique identifier of the channel
    /// @return Current balance locked in the channel
    function getChannelBalance(bytes32 channelId) external view returns (uint256) {
        return channels[channelId].balance;
    }
}
```

**Key Characteristics:**
- **Native ETH payments:** Uses `msg.value`, `payable().transfer()`
- **Unidirectional:** Only sender → recipient payments
- **Off-chain signed claims:** Recipient submits signed claim to close channel
- **Nonce-based replay protection:** Monotonically increasing nonce
- **Time-based expiration:** Sender can reclaim funds after expiration
- **Reentrancy protection:** Uses OpenZeppelin's `ReentrancyGuard`
- **Signature verification:** Uses OpenZeppelin's `ECDSA` and `MessageHashUtils`

**For CronosPaymentChannel.sol, modify:**
1. Add ERC-20 token support (see Contract Modifications Summary below)
2. Replace `msg.value` with `amount` parameter
3. Replace `payable().transfer()` with `aktToken.transfer()`
4. Add constructor to set token address
5. All other logic remains identical

[Reference: Epic 2 Story 2.6 specification]

---

### Contract Modifications Summary

**Total Changes:** ~15 lines modified, ~5 lines added
**Code Reuse:** 95% unchanged from BasePaymentChannel.sol
**Effort:** 1 hour coding + compilation

**Gas Cost Impact (ERC-20 vs Native ETH):**
- ERC-20 transfers add ~35k gas overhead vs native ETH
- openChannel: ~70k gas (vs 50k for Base L2 native ETH)
- closeChannel: ~95k gas (vs 80k for Base L2 native ETH)
- **Total cost on Cronos: ~$0.001** (still 60% cheaper than Base L2 due to lower CRO gas price)
- Micropayment viability: Excellent for payments > $0.05 (gas < 5% of payment)

[Source: docs/research/cronos-akt-deployment/findings/gas-cost-comparison.md]

**Key Modifications:**

1. **Import Addition:**
   ```solidity
   import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   ```

2. **State Variable:**
   ```solidity
   IERC20 public immutable aktToken;
   ```

3. **Constructor:**
   ```solidity
   constructor(address _aktTokenAddress) {
       aktToken = IERC20(_aktTokenAddress);
   }
   ```

4. **openChannel() Changes:**
   - Add `uint256 amount` parameter
   - Remove `payable` modifier
   - Replace `msg.value` with `amount` (3 places)
   - Add `aktToken.transferFrom(msg.sender, address(this), amount);`

5. **closeChannel() Changes:**
   - Replace `payable(recipient).transfer()` → `aktToken.transfer(recipient, claimAmount)`
   - Replace `payable(sender).transfer()` → `aktToken.transfer(sender, refundAmount)`

6. **expireChannel() Changes:**
   - Replace `payable(sender).transfer()` → `aktToken.transfer(sender, balance)`

**Unchanged Functions (100% reuse):**
- `generateChannelId()` - pure function
- `_verifyClaimSignature()` - cryptography logic
- `getChannel()` - view function
- All events, errors, Channel struct

[Source: docs/research/cronos-akt-deployment/findings/contract-modifications.md]

---

### Technology Stack for This Story

**Smart Contract Development:**
- **Language:** Solidity ^0.8.20
- **Framework:** Hardhat 2.x
- **OpenZeppelin:** 5.x (ReentrancyGuard, ECDSA, MessageHashUtils, IERC20)
- **Compiler:** solc 0.8.20+ (via Hardhat)
- **Node.js:** 22.x LTS
- **Package Manager:** pnpm 8.x

**Contract Standards:**
- ERC-20 interface for AKT token integration
- EVM standard cryptographic precompiles (ecrecover)
- OpenZeppelin battle-tested libraries

**Testing (Story 3.2):**
- Hardhat test environment (Mocha/Chai)
- ethers.js v6 for contract interaction
- MockAKT ERC-20 token for testing

[Source: docs/architecture/tech-stack.md, docs/research/cronos-akt-deployment/findings/contract-modifications.md]

---

### File Locations and Naming Conventions

**New Files Created in This Story:**
```
contracts/
├── CronosPaymentChannel.sol          # NEW: Cronos AKT payment channel contract
└── README.md                          # UPDATED: Document contract modifications
```

**Reference Files (If BasePaymentChannel.sol exists):**
```
contracts/
├── BasePaymentChannel.sol             # REFERENCE: Original Base L2 contract
└── CronosPaymentChannel.sol          # NEW: Modified for ERC-20 AKT
```

**Project Structure Context:**
```
nostream-ilp/                          # Project root
├── contracts/                         # Solidity contracts (NEW directory if doesn't exist)
│   ├── BasePaymentChannel.sol        # Base L2 implementation (if exists from Epic 2)
│   ├── CronosPaymentChannel.sol      # NEW: Cronos AKT implementation
│   ├── test/                          # Test helper contracts (Story 3.2)
│   └── README.md                      # Contract documentation
├── scripts/                           # Deployment scripts (Story 3.3)
├── test/                              # Contract tests (Story 3.2)
├── hardhat.config.ts                  # Hardhat configuration (Story 3.3)
├── package.json                       # Dependencies
└── tsconfig.json                      # TypeScript config
```

**Naming Conventions:**
- Contract file: `CronosPaymentChannel.sol` (matches contract name)
- Contract name: `CronosPaymentChannel` (not `BasePaymentChannel`)
- State variables: camelCase (`aktToken`, not `akt_token`)
- Functions: camelCase (`openChannel`, not `open_channel`)
- Constants: UPPER_SNAKE_CASE (if any)

[Source: docs/architecture/source-tree-structure.md, Solidity style guide]

---

### Data Models and Contract State

**Channel Struct (Unchanged from Base L2):**
```solidity
struct Channel {
    address sender;        // Payer's address (Cronos address)
    address recipient;     // Relay's address (Cronos address)
    uint256 balance;       // Locked AKT amount (in base units, 6 decimals)
    uint256 highestNonce;  // Last verified nonce (prevents replay)
    uint256 expiration;    // Unix timestamp when channel expires
    bool isClosed;         // Channel status flag
}
```

**Storage Layout:**
```solidity
mapping(bytes32 => Channel) public channels;  // channelId => Channel state
IERC20 public immutable aktToken;             // AKT ERC-20 token reference
```

**AKT Token Properties:**
- **Standard:** ERC-20 (CRC-20 compatible on Cronos)
- **Decimals:** 6 (not 18 like ETH)
- **Mainnet Address:** `0x39a65A74Dc5A778Ff93d1765Ea51F57BC49c81B3`
- **Base Unit:** 1 AKT = 1,000,000 base units (uakt)

**Payment Flow:**
1. User approves contract: `aktToken.approve(contractAddress, amount)`
2. User opens channel: `openChannel(recipient, expiration, amount)`
   - Contract calls `aktToken.transferFrom(user, contract, amount)`
   - Channel state stored with balance
3. User makes micropayments off-chain (signed claims)
4. Recipient closes channel: `closeChannel(channelId, claimAmount, nonce, signature)`
   - Contract verifies signature
   - Transfers `claimAmount` to recipient: `aktToken.transfer(recipient, claimAmount)`
   - Refunds remaining to sender: `aktToken.transfer(sender, refund)`

[Source: docs/architecture/data-models.md#cosmwasmpaymentchannel, docs/research/cronos-akt-deployment/findings/akt-token-integration.md]

---

### Security Considerations

**ERC-20 Specific Risks:**

1. **Approval Front-Running:**
   - **Risk:** User approves contract for large amount, attacker could exploit if contract has vulnerability
   - **Mitigation:** Contract uses exact `transferFrom` amounts, no unlimited approval needed
   - **User Best Practice:** Approve only amount needed for channel

2. **Reentrancy on Token Transfers:**
   - **Protection:** OpenZeppelin's `ReentrancyGuard` protects `closeChannel()`
   - **Note:** ERC-20 transfers don't trigger fallback functions, lower reentrancy risk than native ETH

3. **Token Contract Trust:**
   - **Risk:** Malicious token contract could fail transfers silently
   - **Mitigation:** Use official AKT token address (immutable, set in constructor)
   - **Verification:** Constructor parameter must be verified during deployment

4. **Integer Overflow/Underflow:**
   - **Protection:** Solidity 0.8.20+ has built-in overflow checks
   - **No change from BasePaymentChannel:** Same arithmetic operations

**Signature Verification (Unchanged):**
- Uses OpenZeppelin ECDSA library (battle-tested)
- Signature format: `keccak256(abi.encodePacked(channelId, claimAmount, nonce))`
- Nonce prevents replay attacks (monotonically increasing)

**Contract Immutability:**
- `aktToken` is `immutable` - set once in constructor, cannot be changed
- No upgrade mechanism - contract is final once deployed
- Security audit recommended before mainnet deployment (Story 3.6)

[Source: docs/architecture/security-architecture.md, OpenZeppelin security best practices]

---

### Known Constraints and Dependencies

**Blockers:**
- None - this is the first story of Epic 3

**Prerequisites:**
- Node.js 22.x LTS installed
- Hardhat development environment (can be initialized in this story)
- OpenZeppelin contracts package installed

**External Dependencies:**
- OpenZeppelin Contracts 5.x (IERC20, ReentrancyGuard, ECDSA)
- Solidity compiler 0.8.20+
- Hardhat toolchain

**Assumptions:**
- Complete BasePaymentChannel.sol reference implementation is provided in Dev Notes (see "BasePaymentChannel.sol Reference Implementation" section above)
- If BasePaymentChannel.sol exists in repository from Epic 2, it can be used instead of the reference implementation
- AKT token address `0x39a65A74Dc5A778Ff93d1765Ea51F57BC49c81B3` is correct for Cronos mainnet
- Testnet will use MockAKT (Story 3.2)
- Hardhat project can be initialized if it doesn't exist

**Deferred to Future Stories:**
- Testing (Story 3.2): MockAKT token, test suite modifications
- Deployment (Story 3.3): Hardhat configuration for Cronos networks
- Verification (Story 3.4): CronoScan contract verification
- Integration (Story 3.5): Dassie settlement module for Cronos

[Source: docs/prd/epic-3-cosmwasm-payment-channel-contract.md]

---

### Testing

**IMPORTANT - Testing Dependency:**

**Testing for this story is explicitly deferred to Story 3.2.** This story (3.1) focuses ONLY on contract code creation and compilation. Story 3.2 depends on successful completion of this story and will implement the full test suite.

**Acceptance Criteria for Story 3.1:**
- ✅ Contract compiles successfully (`npx hardhat compile` succeeds)
- ✅ No compilation errors or warnings
- ❌ Do NOT write tests in this story
- ❌ Do NOT attempt to deploy or execute the contract

**When Story 3.1 is complete:**
- Mark story as "Done" when compilation succeeds
- All acceptance criteria (AC 1-10) are met through code changes and successful compilation
- Story 3.2 will then add MockAKT token and comprehensive test suite

**Testing Standards (Story 3.2 will implement):**

**Framework:** Hardhat with Mocha/Chai
**Test Location:** `test/CronosPaymentChannel.test.ts`

**Test Approach:**
- Unit tests with MockAKT ERC-20 token
- Replace `ethers.provider.getBalance()` with `aktToken.balanceOf()`
- Replace `ethers.parseEther()` with `ethers.parseUnits(amount, 6)` (6 decimals for AKT)
- Add approval step before all `openChannel()` calls
- Test new error cases: insufficient approval, insufficient token balance

**Coverage Target:** >90% (matching Epic 2 standards)

**Test Commands (Story 3.2):**
```bash
npx hardhat test                           # Run all tests
npx hardhat test --grep "CronosPaymentChannel"  # Run Cronos tests only
npx hardhat coverage                       # Generate coverage report
```

[Source: docs/architecture/tech-stack.md#testing-unit, docs/research/cronos-akt-deployment/findings/contract-modifications.md#testing-modifications]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-28 | 1.0 | Initial story creation for Epic 3 Story 1 | Claude Code (Sonnet 4.5) |
| 2025-11-28 | 1.1 | Fixed validation issues: Added complete BasePaymentChannel.sol reference implementation, clarified source tree structure, added explicit testing dependency note, enhanced Hardhat initialization guidance, added constructor validation, added gas estimation context, locked compiler version | Claude Code (Sonnet 4.5) |

---

## Dev Agent Record

### Agent Model Used

**Primary Model:** Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)
**Agent Name:** James (Dev Agent - Full Stack Developer)
**Session Date:** 2025-11-28

### Debug Log References

**Implementation Issues Encountered:**

1. **Hardhat Version Compatibility (Resolved)**
   - **Issue:** Hardhat 3.x installed initially, requires ESM (`"type": "module"`)
   - **Problem:** Project uses CommonJS (.eslintrc.js, knexfile.js, etc.)
   - **Solution:** Downgraded to Hardhat 2.27.1 for CommonJS compatibility
   - **Command:** `pnpm remove hardhat @nomicfoundation/hardhat-toolbox && pnpm add -D hardhat@^2.19.0 @nomicfoundation/hardhat-toolbox@^4.0.0`

2. **Chai Version Compatibility (Resolved)**
   - **Issue:** chai@6.2.1 (ESM-only) incompatible with Hardhat 2.x (CommonJS)
   - **Error:** `Error [ERR_REQUIRE_ESM]: require() of ES Module .../chai/index.js`
   - **Solution:** Downgraded to chai@4.5.0 and @types/chai@4.3.0
   - **Command:** `pnpm add -D chai@^4.5.0 @types/chai@^4.3.0`

3. **BasePaymentChannel.sol Not Found (Expected)**
   - **Issue:** BasePaymentChannel.sol did not exist in repository
   - **Solution:** Created from reference implementation in Dev Notes section
   - **Outcome:** Baseline contract created successfully, compiled without errors

**No Debug Log Entries Required:** All issues resolved during implementation. No blockers encountered.

### Completion Notes List

**Implementation Summary:**

1. **Environment Setup (Task 1):**
   - ✅ Verified Node.js v22.11.0 installed
   - ✅ Installed Hardhat 2.27.1, OpenZeppelin 5.4.0, hardhat-toolbox 4.0.0
   - ✅ Downgraded chai to 4.5.0 for Hardhat 2.x compatibility
   - ✅ Created hardhat.config.ts with Solidity 0.8.20 locked
   - ✅ Created contracts/ directory
   - ✅ Initial compilation test successful

2. **BasePaymentChannel.sol Creation (Task 2):**
   - ✅ Checked for existing BasePaymentChannel.sol (not found)
   - ✅ Created BasePaymentChannel.sol from reference implementation (208 lines)
   - ✅ Compiled successfully: "Compiled 9 Solidity files successfully"

3. **CronosPaymentChannel.sol Implementation (Tasks 3-7):**
   - ✅ Created CronosPaymentChannel.sol (231 lines)
   - ✅ Added IERC20 import and aktToken state variable
   - ✅ Added constructor with address(0) validation
   - ✅ Modified openChannel(): Added amount parameter, removed payable, added transferFrom
   - ✅ Modified closeChannel(): Replaced payable().transfer() with aktToken.transfer() (2 places)
   - ✅ Modified expireChannel(): Replaced payable().transfer() with aktToken.transfer()
   - ✅ Verified unchanged functions: generateChannelId, _verifyClaimSignature, getChannel, isChannelOpen, getChannelBalance

4. **Compilation & Verification (Task 8):**
   - ✅ Final compilation: "Compiled 2 Solidity files successfully (evm target: paris)"
   - ✅ 0 errors, 0 warnings
   - ✅ TypeChain types generated: 24 typings
   - ✅ Artifacts created in artifacts/contracts/

5. **Documentation (Tasks 9-10):**
   - ✅ Added complete NatSpec comments to all functions
   - ✅ Documented constructor parameter and approval requirement
   - ✅ Created contracts/README.md (comprehensive usage guide)
   - ✅ Comparison documentation already exists: docs/research/cronos-akt-deployment/findings/contract-modifications.md

**Code Quality Metrics:**
- **Code Reuse:** 95% unchanged from BasePaymentChannel.sol
- **Lines Modified:** ~15 lines
- **Lines Added:** ~7 lines (import, state variable, constructor)
- **Functions Modified:** 3 (openChannel, closeChannel, expireChannel)
- **Functions Unchanged:** 5 (generateChannelId, _verifyClaimSignature, getChannel, isChannelOpen, getChannelBalance)
- **Compilation Time:** <5 seconds
- **Development Time:** ~1 hour

### Test Results

**Status:** ✅ **DEFERRED TO STORY 3.2** (As specified in Acceptance Criteria)

**Story 3.1 Validation:**
- ✅ Contract compiles successfully without errors
- ✅ Contract compiles without warnings
- ✅ TypeChain types generated successfully
- ✅ Artifacts directory populated correctly

**Testing Notes:**
- Story 3.1 acceptance criteria state: "Contract compiles successfully" as the validation requirement
- Story explicitly notes: "IMPORTANT - Testing Dependency: Testing for this story is explicitly deferred to Story 3.2"
- Story 3.2 will implement:
  - MockAKT ERC-20 token for testing
  - Full test suite with approval flows
  - Coverage target: >90%

**Manual Verification Performed:**
- ✅ Solidity syntax validation via compilation
- ✅ OpenZeppelin imports resolution verified
- ✅ Contract structure review completed
- ✅ NatSpec documentation completeness checked

### File List

**New Files Created:**

1. **hardhat.config.ts** (324 bytes)
   - Hardhat configuration with Solidity 0.8.20
   - Compiler optimizer enabled (200 runs)

2. **contracts/BasePaymentChannel.sol** (6,820 bytes)
   - Reference implementation for native ETH payment channels
   - Base L2 deployment target
   - 208 lines, 9 functions, 100% unchanged from reference

3. **contracts/CronosPaymentChannel.sol** (7,142 bytes)
   - Modified for ERC-20 AKT token support
   - Cronos deployment target
   - 231 lines, 9 functions (3 modified, 5 unchanged, 1 new constructor)

4. **contracts/README.md** (6,513 bytes)
   - Comprehensive contract documentation
   - Usage examples for both contracts
   - Gas cost estimates
   - Security considerations
   - Deployment instructions

**Modified Files:**

1. **package.json**
   - Added devDependencies:
     - hardhat@^2.19.0
     - @nomicfoundation/hardhat-toolbox@^4.0.0
     - @openzeppelin/contracts@^5.4.0
     - chai@^4.5.0
     - @types/chai@^4.3.0

**Generated Files (Artifacts):**

- `artifacts/contracts/BasePaymentChannel.sol/` - Compiled artifacts
- `artifacts/contracts/CronosPaymentChannel.sol/` - Compiled artifacts
- `typechain-types/` - TypeChain TypeScript types (24 files)
- `cache/` - Hardhat compilation cache

**Existing Documentation Referenced:**

- `docs/research/cronos-akt-deployment/findings/contract-modifications.md` - Side-by-side comparison (already exists)
- `docs/research/cronos-akt-deployment/README.md` - Research summary
- `docs/prd/epic-3-cosmwasm-payment-channel-contract.md` - Epic PRD

**Total New/Modified Source Files:** 5 files (4 new, 1 modified)

---

## QA Results

### Review Date: 2025-11-28

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment: EXCELLENT (with critical security fix applied)**

The implementation demonstrates high-quality code with excellent adherence to the story requirements. The contract successfully achieves the stated goal of 95% code reuse from BasePaymentChannel.sol while cleanly adapting to ERC-20 token mechanics. All 10 acceptance criteria are fully met.

**Strengths:**
- Clean, minimal modifications from BasePaymentChannel.sol (exactly as specified)
- Proper use of OpenZeppelin battle-tested libraries (ReentrancyGuard, ECDSA, MessageHashUtils, IERC20)
- Comprehensive NatSpec documentation throughout
- Excellent constructor validation (address(0) check)
- Immutable token reference prevents post-deployment tampering
- Solidity 0.8.20 provides automatic overflow protection

**Critical Security Finding Identified and Resolved:**
During review, I identified that ERC-20 transfer return values were not checked, which is a **HIGH severity** vulnerability. This has been fixed (see Refactoring Performed section).

### Refactoring Performed

**CRITICAL SECURITY FIX - ERC-20 Transfer Return Value Validation**

- **File**: contracts/CronosPaymentChannel.sol
- **Lines Modified**: 79, 141, 146, 165
- **Change**: Added `require()` checks to all ERC-20 `transfer()` and `transferFrom()` calls
- **Why**: Some ERC-20 tokens return `false` instead of reverting on failure. Without checking return values, silent failures could occur, leading to loss of funds. This is a well-known vulnerability pattern (e.g., USDT on Ethereum).
- **How**: Wrapped each token transfer in `require(tokenCall, "Error message")` to ensure transaction reverts if transfer fails
- **Impact**: Eliminates risk of silent transfer failures and fund loss

**Specific Changes:**

1. **openChannel() - Line 79:**
   ```solidity
   // BEFORE:
   aktToken.transferFrom(msg.sender, address(this), amount);

   // AFTER:
   require(aktToken.transferFrom(msg.sender, address(this), amount), "Transfer failed");
   ```

2. **closeChannel() - Line 141:**
   ```solidity
   // BEFORE:
   aktToken.transfer(channel.recipient, claimAmount);

   // AFTER:
   require(aktToken.transfer(channel.recipient, claimAmount), "Transfer to recipient failed");
   ```

3. **closeChannel() - Line 146:**
   ```solidity
   // BEFORE:
   aktToken.transfer(channel.sender, refundAmount);

   // AFTER:
   require(aktToken.transfer(channel.sender, refundAmount), "Refund to sender failed");
   ```

4. **expireChannel() - Line 165:**
   ```solidity
   // BEFORE:
   aktToken.transfer(channel.sender, channel.balance);

   // AFTER:
   require(aktToken.transfer(channel.sender, channel.balance), "Refund failed");
   ```

### Compliance Check

- **Coding Standards**: ✓ N/A (no project-specific Solidity standards document exists)
  - Follows Solidity style guide: camelCase functions, UPPER_SNAKE_CASE errors, proper NatSpec
  - Consistent with OpenZeppelin patterns
- **Project Structure**: ✓ PASS
  - Contracts placed in `contracts/` directory as specified
  - Hardhat configuration at repository root
  - Documentation in `contracts/README.md`
- **Testing Strategy**: ✓ DEFERRED TO STORY 3.2 (as specified in acceptance criteria)
  - Story explicitly states: "Testing for this story is explicitly deferred to Story 3.2"
  - Compilation test passing is the validation requirement for Story 3.1
- **All ACs Met**: ✓ PASS (10/10 acceptance criteria fully satisfied)
  - AC1: CronosPaymentChannel.sol created ✓
  - AC2: IERC20 import added ✓
  - AC3: aktToken state variable added ✓
  - AC4: Constructor with validation added ✓
  - AC5: openChannel() modified correctly ✓
  - AC6: closeChannel() modified correctly ✓
  - AC7: expireChannel() modified correctly ✓
  - AC8: Unchanged functions verified ✓
  - AC9: Contract compiles successfully ✓
  - AC10: Code changes documented ✓

### Improvements Checklist

**Completed by QA:**
- [x] Fixed ERC-20 transfer return value checks (contracts/CronosPaymentChannel.sol:79,141,146,165)
- [x] Verified contract compiles after security fixes
- [x] Comprehensive code review completed
- [x] Requirements traceability verified

**No Further Action Required:**
All improvements have been applied. Contract is production-ready from a code quality perspective (pending testing in Story 3.2 and security audit in Story 3.6).

### Security Review

**Security Assessment: PASS (after fixes applied)**

**Vulnerabilities Identified and Fixed:**
1. **ERC-20 Transfer Return Value [HIGH] - FIXED**
   - Unchecked return values from `transfer()` and `transferFrom()`
   - Could lead to silent failures and fund loss with non-standard ERC-20 tokens
   - Fixed by adding `require()` checks to all 4 token transfer calls

**Security Strengths:**
- ✓ Reentrancy protection via OpenZeppelin ReentrancyGuard on `closeChannel()`
- ✓ Signature verification using battle-tested OpenZeppelin ECDSA library
- ✓ Nonce-based replay attack prevention (monotonically increasing)
- ✓ Immutable token address prevents post-deployment tampering
- ✓ Constructor validation prevents zero address token
- ✓ Solidity 0.8.20 built-in overflow/underflow protection
- ✓ Proper validation order (checks-effects-interactions pattern in closeChannel)
- ✓ No delegatecall or selfdestruct vulnerabilities
- ✓ No unchecked external calls

**Recommendations for Future:**
- Professional security audit before mainnet deployment (Story 3.6)
- Consider using OpenZeppelin's SafeERC20 library for additional safety (alternative to require() checks)
- Fuzz testing for edge cases (especially signature verification)
- Gas optimization review (though current gas costs are acceptable per research)

**No Critical Issues Remaining:** All identified security issues have been resolved.

### Performance Considerations

**Performance Assessment: EXCELLENT**

**Gas Costs (Estimated from Research):**
- openChannel: ~70,000 gas (~$0.001 on Cronos)
- closeChannel: ~95,000 gas (~$0.0015 on Cronos)
- expireChannel: ~65,000 gas (~$0.001 on Cronos)

**Analysis:**
- ERC-20 adds ~35k gas overhead vs native ETH (expected and acceptable)
- Cronos gas prices are 60-70% cheaper than Base L2, offsetting ERC-20 overhead
- Micropayment viability: Excellent for payments > $0.05 (gas < 5% of payment)
- No obvious gas optimizations needed at this stage
- Compiler optimizer enabled (200 runs) balances deployment and execution costs

**Performance Strengths:**
- Efficient storage usage (single mapping, no arrays)
- Pure functions (generateChannelId) save gas
- No loops or unbounded operations
- Minimal state changes per transaction

### Files Modified During Review

**Modified by QA:**
1. `contracts/CronosPaymentChannel.sol` - Added ERC-20 transfer return value checks (4 lines modified)

**Developer should update File List in story to include this security fix.**

### Gate Status

**Gate: PASS** → docs/qa/gates/3.1-modify-base-payment-channel-for-erc20-akt-support.yml

**Quality Score: 95/100**
- Deduction: -5 for critical security issue found (though immediately fixed)
- High score reflects excellent implementation quality, comprehensive documentation, and full AC coverage

### Requirements Traceability

**Acceptance Criteria Coverage: 10/10 (100%)**

All acceptance criteria have corresponding implementation with full traceability:

| AC # | Requirement | Implementation | Status |
|------|-------------|----------------|--------|
| 1 | Create CronosPaymentChannel.sol | contracts/CronosPaymentChannel.sol:1-226 | ✓ PASS |
| 2 | Add IERC20 import | contracts/CronosPaymentChannel.sol:7 | ✓ PASS |
| 3 | Add aktToken state variable | contracts/CronosPaymentChannel.sol:17 | ✓ PASS |
| 4 | Add constructor | contracts/CronosPaymentChannel.sol:57-60 | ✓ PASS |
| 5 | Modify openChannel() | contracts/CronosPaymentChannel.sol:68-104 | ✓ PASS |
| 6 | Modify closeChannel() | contracts/CronosPaymentChannel.sol:111-150 | ✓ PASS |
| 7 | Modify expireChannel() | contracts/CronosPaymentChannel.sol:154-168 | ✓ PASS |
| 8 | Verify unchanged functions | contracts/CronosPaymentChannel.sol:175-224 | ✓ PASS |
| 9 | Contract compiles successfully | Verified via `npx hardhat compile` | ✓ PASS |
| 10 | Code changes documented | contracts/README.md, research docs | ✓ PASS |

**Test Coverage: DEFERRED TO STORY 3.2**
- Story 3.1 explicitly defers testing to Story 3.2
- Validation via successful compilation is sufficient for this story

### Non-Functional Requirements Validation

**Security: PASS** (after security fix applied)
- Reentrancy protection: ✓
- Signature verification: ✓
- Input validation: ✓
- Transfer safety: ✓ (fixed during review)

**Performance: PASS**
- Gas costs within acceptable range
- No performance bottlenecks identified
- Compiler optimization enabled

**Reliability: PASS**
- Error handling comprehensive (7 custom errors)
- No silent failures (all transfers now checked)
- Proper state management

**Maintainability: PASS**
- Excellent code clarity and documentation
- NatSpec comments on all public functions
- Clean diff from BasePaymentChannel.sol
- Well-structured README

### Recommended Status

**✓ Ready for Done**

**Justification:**
- All 10 acceptance criteria fully met
- Critical security issue identified and fixed
- Contract compiles successfully with 0 errors, 0 warnings
- Code quality exceeds expectations
- Comprehensive documentation provided
- No blocking issues remain

**Next Steps:**
1. Story owner to mark status as "Done"
2. Story owner to update File List with QA security fix
3. Proceed to Story 3.2 (testing) with confidence in contract implementation

---
