# Story 2.12: Create Docker Images for Monorepo Services

## Status

Draft

## Story

**As a** developer,
**I want** Docker images for both Nostream and Dassie built from the monorepo,
**so that** I can deploy both services to Akash with proper isolation and resource management.

## Acceptance Criteria

1. `docker/Dockerfile.nostream` - Multi-stage build from monorepo
2. `docker/Dockerfile.dassie` - Multi-stage build from monorepo
3. Both images use node:22-alpine base
4. Optimized layer caching (dependencies installed before code copy)
5. Health check endpoints configured in Dockerfiles
6. Images build successfully: `docker-compose build`
7. Both services start: `docker-compose up`
8. Nostream can connect to Dassie RPC (service discovery works)
9. Environment variables properly injected
10. Image sizes optimized (<500MB per image)

## Tasks / Subtasks

- [ ] Task 1: Create Nostream Dockerfile (AC: 1, 3, 4, 5)
  - [ ] Create `docker/Dockerfile.nostream`:
    ```dockerfile
    # Stage 1: Dependencies
    FROM node:22-alpine AS deps
    RUN corepack enable
    WORKDIR /app

    # Copy workspace config
    COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
    COPY packages/app-nostream/package.json ./packages/app-nostream/
    COPY packages/lib-payment-types/package.json ./packages/lib-payment-types/
    COPY packages/lib-contracts/package.json ./packages/lib-contracts/

    # Install dependencies
    RUN pnpm install --frozen-lockfile --filter app-nostream...

    # Stage 2: Build
    FROM node:22-alpine AS builder
    RUN corepack enable
    WORKDIR /app

    # Copy deps from previous stage
    COPY --from=deps /app/node_modules ./node_modules
    COPY --from=deps /app/packages ./packages

    # Copy source code
    COPY packages/app-nostream ./packages/app-nostream
    COPY packages/lib-payment-types ./packages/lib-payment-types
    COPY tsconfig.base.json ./

    # Build
    RUN pnpm --filter app-nostream build

    # Stage 3: Production
    FROM node:22-alpine
    RUN apk add --no-cache curl
    WORKDIR /app

    # Copy production dependencies
    COPY --from=deps /app/node_modules ./node_modules
    COPY --from=builder /app/packages/app-nostream/dist ./dist

    # Create .nostr directory for config
    RUN mkdir -p /home/node/.nostr && chown -R node:node /home/node

    USER node
    EXPOSE 8008
    HEALTHCHECK --interval=30s --timeout=10s --retries=3 --start-period=40s \
      CMD curl -f http://localhost:8008/health || exit 1

    CMD ["node", "dist/index.js"]
    ```
  - [ ] Test build: `docker build -f docker/Dockerfile.nostream -t nostream-ilp:latest .`
  - [ ] Verify image size: `docker images | grep nostream-ilp`

- [ ] Task 2: Create Dassie Dockerfile (AC: 2, 3, 4, 5)
  - [ ] Create `docker/Dockerfile.dassie`:
    ```dockerfile
    # Stage 1: Dependencies
    FROM node:22-alpine AS deps
    RUN corepack enable
    WORKDIR /app

    # Copy workspace config
    COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
    COPY packages/app-dassie/package.json ./packages/app-dassie/
    COPY packages/lib-payment-types/package.json ./packages/lib-payment-types/
    COPY packages/lib-dassie-*/package.json ./packages/lib-dassie-*/

    # Install dependencies (including Dassie libs)
    RUN pnpm install --frozen-lockfile --filter app-dassie...

    # Stage 2: Build
    FROM node:22-alpine AS builder
    RUN corepack enable
    WORKDIR /app

    # Copy deps
    COPY --from=deps /app/node_modules ./node_modules
    COPY --from=deps /app/packages ./packages

    # Copy source
    COPY packages/app-dassie ./packages/app-dassie
    COPY packages/lib-dassie-* ./packages/
    COPY packages/lib-payment-types ./packages/lib-payment-types
    COPY tsconfig.base.json ./

    # Build
    RUN pnpm --filter app-dassie build

    # Stage 3: Production
    FROM node:22-alpine
    RUN apk add --no-cache curl sqlite
    WORKDIR /app

    # Copy production artifacts
    COPY --from=deps /app/node_modules ./node_modules
    COPY --from=builder /app/packages/app-dassie/dist ./dist

    # Create data directory for Dassie ledger
    RUN mkdir -p /app/data && chown -R node:node /app/data

    USER node
    EXPOSE 7768
    HEALTHCHECK --interval=30s --timeout=10s --retries=3 --start-period=60s \
      CMD curl -f http://localhost:7768/health || exit 1

    CMD ["node", "dist/index.js"]
    ```
  - [ ] Test build: `docker build -f docker/Dockerfile.dassie -t dassie-node:latest .`
  - [ ] Verify image size

- [ ] Task 3: Update docker-compose.yml for Monorepo (AC: 6, 7, 8, 9)
  - [ ] Update `docker-compose.yml`:
    ```yaml
    services:
      nostream:
        build:
          context: .
          dockerfile: docker/Dockerfile.nostream
        image: nostream-ilp:latest
        container_name: nostream-ilp
        environment:
          # Core
          SECRET: ${SECRET}
          RELAY_PORT: 8008
          NOSTR_CONFIG_DIR: /home/node/.nostr

          # Database
          DB_HOST: nostream-db
          DB_PORT: 5432
          DB_USER: nostr_ts_relay
          DB_PASSWORD: ${DB_PASSWORD:-nostr_ts_relay}
          DB_NAME: nostr_ts_relay

          # Redis
          REDIS_HOST: nostream-cache
          REDIS_PORT: 6379
          REDIS_PASSWORD: ${REDIS_PASSWORD:-nostr_ts_relay}

          # BTP-NIPs
          BTP_NIPS_ENABLED: 'true'

          # Dassie RPC (NEW - service discovery)
          DASSIE_RPC_URL: ws://dassie:7768/trpc
          DASSIE_RPC_TOKEN: ${DASSIE_RPC_TOKEN}
        ports:
          - "8008:8008"
        depends_on:
          nostream-db:
            condition: service_healthy
          nostream-cache:
            condition: service_healthy
          dassie:
            condition: service_healthy
        networks:
          - nostream-ilp

      dassie:
        build:
          context: .
          dockerfile: docker/Dockerfile.dassie
        image: dassie-node:latest
        container_name: dassie-node
        environment:
          # Dassie config
          NODE_ENV: production
          RPC_AUTH_TOKEN: ${DASSIE_RPC_TOKEN}
          LEDGER_DB_PATH: /app/data/ledger.db

          # Settlement modules
          SETTLEMENT_BASE_ENABLED: ${SETTLEMENT_BASE_ENABLED:-false}
          SETTLEMENT_BASE_RPC_URL: ${SETTLEMENT_BASE_RPC_URL}
          SETTLEMENT_BASE_FACTORY_ADDRESS: ${SETTLEMENT_BASE_FACTORY_ADDRESS}
          SETTLEMENT_BASE_RELAY_PRIVATE_KEY: ${SETTLEMENT_BASE_RELAY_PRIVATE_KEY}

          SETTLEMENT_CRONOS_ENABLED: ${SETTLEMENT_CRONOS_ENABLED:-false}
          SETTLEMENT_CRONOS_RPC_URL: ${SETTLEMENT_CRONOS_RPC_URL}
          SETTLEMENT_CRONOS_FACTORY_ADDRESS: ${SETTLEMENT_CRONOS_FACTORY_ADDRESS}
          SETTLEMENT_CRONOS_RELAY_PRIVATE_KEY: ${SETTLEMENT_CRONOS_RELAY_PRIVATE_KEY}
        ports:
          - "7768:7768"
        volumes:
          - dassie-data:/app/data
        networks:
          - nostream-ilp

      # ... existing nostream-db, nostream-cache services ...

    volumes:
      postgres-data:
      postgres-logs:
      dassie-data:

    networks:
      nostream-ilp:
        driver: bridge
    ```
  - [ ] Update service dependencies (nostream depends on dassie)
  - [ ] Add dassie-data volume for persistent ledger
  - [ ] Configure service discovery (ws://dassie:7768)

- [ ] Task 4: Update .env.example (AC: 9)
  - [ ] Add Dassie-specific environment variables:
    ```bash
    # Dassie RPC Authentication
    DASSIE_RPC_TOKEN=your-token-here-min-32-chars

    # Base L2 Settlement (optional)
    SETTLEMENT_BASE_ENABLED=false
    SETTLEMENT_BASE_RPC_URL=https://sepolia.base.org
    SETTLEMENT_BASE_FACTORY_ADDRESS=0x...
    SETTLEMENT_BASE_RELAY_PRIVATE_KEY=0x...

    # Cronos Settlement (optional)
    SETTLEMENT_CRONOS_ENABLED=false
    SETTLEMENT_CRONOS_RPC_URL=https://evm-t3.cronos.org
    SETTLEMENT_CRONOS_FACTORY_ADDRESS=0x9Ec2d217b14e67cAbF86F20F4E7462D6d7bc7684
    SETTLEMENT_CRONOS_RELAY_PRIVATE_KEY=0x...
    ```
  - [ ] Add comments explaining each variable
  - [ ] Reference generation commands (e.g., `openssl rand -hex 32`)

- [ ] Task 5: Optimize Image Sizes (AC: 10)
  - [ ] Review dependencies - remove dev dependencies from production
  - [ ] Use `.dockerignore` to exclude unnecessary files:
    ```
    node_modules
    .git
    .github
    docs
    test
    *.md
    .env*
    dist
    ```
  - [ ] Minimize layers (combine RUN commands where possible)
  - [ ] Use multi-stage builds (already done in Tasks 1-2)
  - [ ] Target: Nostream <400MB, Dassie <450MB
  - [ ] Measure: `docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"`

- [ ] Task 6: Add Health Check Scripts (AC: 5)
  - [ ] Create `packages/app-nostream/healthcheck.js`:
    ```javascript
    const http = require('http');

    const options = {
      hostname: 'localhost',
      port: 8008,
      path: '/health',
      method: 'GET',
      timeout: 5000
    };

    const req = http.request(options, (res) => {
      if (res.statusCode === 200) {
        process.exit(0);
      } else {
        process.exit(1);
      }
    });

    req.on('error', () => process.exit(1));
    req.on('timeout', () => process.exit(1));
    req.end();
    ```
  - [ ] Create similar `packages/app-dassie/healthcheck.js`
  - [ ] Update Dockerfiles to use: `HEALTHCHECK CMD node healthcheck.js`
  - [ ] Test health checks: `docker inspect --format='{{.State.Health.Status}}' nostream-ilp`

- [ ] Task 7: Test Inter-Service Communication (AC: 8)
  - [ ] Start stack: `docker-compose up -d`
  - [ ] Check Dassie health: `curl http://localhost:7768/health`
  - [ ] Check Nostream health: `curl http://localhost:8008/health`
  - [ ] Test Nostream → Dassie RPC connection:
    - Check Nostream logs for "Connected to Dassie RPC"
    - Verify no connection errors in logs
  - [ ] Test payment verification flow:
    - Send Nostr event with payment claim
    - Verify Dassie RPC called successfully
  - [ ] Stop stack: `docker-compose down`

- [ ] Task 8: Create Build Scripts (AC: 6)
  - [ ] Update `scripts/docker-build.sh`:
    ```bash
    #!/bin/bash
    set -e

    echo "Building Docker images from monorepo..."

    # Build Nostream
    echo "Building Nostream..."
    docker build -f docker/Dockerfile.nostream -t nostream-ilp:latest .

    # Build Dassie
    echo "Building Dassie..."
    docker build -f docker/Dockerfile.dassie -t dassie-node:latest .

    # Tag for registry (optional)
    if [ ! -z "$REGISTRY" ]; then
      docker tag nostream-ilp:latest $REGISTRY/nostream-ilp:latest
      docker tag dassie-node:latest $REGISTRY/dassie-node:latest
    fi

    echo "Build complete!"
    docker images | grep -E "nostream-ilp|dassie-node"
    ```
  - [ ] Make executable: `chmod +x scripts/docker-build.sh`
  - [ ] Update `package.json`:
    ```json
    {
      "scripts": {
        "docker:build": "./scripts/docker-build.sh",
        "docker:start": "./scripts/docker-start.sh",
        "docker:stop": "./scripts/docker-stop.sh"
      }
    }
    ```

- [ ] Task 9: Update Documentation (AC: all)
  - [ ] Update `README.md` Docker section:
    - New monorepo build instructions
    - Both services architecture diagram
    - Environment variables for Dassie
  - [ ] Create `docker/README.md`:
    - Dockerfile explanations
    - Multi-stage build strategy
    - Image optimization techniques
    - Troubleshooting common issues
  - [ ] Update `docs/architecture/deployment-architecture.md`:
    - Add Dassie service diagram
    - Service communication flow
    - Docker networking setup

- [ ] Task 10: Integration Testing (AC: 6, 7, 8)
  - [ ] Create `test/integration/docker-services.spec.ts`:
    ```typescript
    describe('Docker Services Integration', () => {
      beforeAll(async () => {
        // Start docker-compose
        await exec('docker-compose up -d')
        await sleep(30000)  // Wait for services to start
      })

      it('should have nostream container running', async () => {
        const result = await exec('docker ps | grep nostream-ilp')
        expect(result).toContain('Up')
      })

      it('should have dassie container running', async () => {
        const result = await exec('docker ps | grep dassie-node')
        expect(result).toContain('Up')
      })

      it('should connect to Nostream via HTTP', async () => {
        const response = await fetch('http://localhost:8008/health')
        expect(response.status).toBe(200)
      })

      it('should connect to Dassie via HTTP', async () => {
        const response = await fetch('http://localhost:7768/health')
        expect(response.status).toBe(200)
      })

      it('should verify Nostream can reach Dassie RPC', async () => {
        const logs = await exec('docker logs nostream-ilp')
        expect(logs).toMatch(/Connected to Dassie|RPC connection established/)
      })

      afterAll(async () => {
        await exec('docker-compose down')
      })
    })
    ```
  - [ ] Run tests: `pnpm test:integration:docker`

## Dev Notes

### Architecture Context

**Multi-Service Docker Architecture:**

This story creates Docker images for both Nostream and Dassie from the monorepo. The services run in separate containers but communicate via Docker networking.

**Service Communication:**
```
┌─────────────────┐
│   Nostream      │
│   :8008         │──┐
└─────────────────┘  │
                     │ WebSocket RPC
                     │ ws://dassie:7768/trpc
                     │
                     ▼
              ┌─────────────────┐
              │   Dassie        │
              │   :7768         │
              └─────────────────┘
```

[Source: Story 2.10 monorepo architecture, Epic 8 deployment]

---

### Multi-Stage Build Benefits

**Why 3 stages?**

1. **Deps Stage**: Install dependencies
   - Cached separately (only reinstall if package.json changes)
   - pnpm workspace resolution

2. **Builder Stage**: Compile TypeScript
   - Build all packages
   - Generate production bundles

3. **Production Stage**: Minimal runtime
   - Only production dependencies
   - No build tools (TypeScript, etc.)
   - Smallest possible image

**Layer Caching:**
- Package.json copied first → cache dependencies
- Source code copied last → invalidate only on code changes
- Rebuilds are fast (30s instead of 5min)

[Source: Docker multi-stage build best practices]

---

### Image Size Optimization

**Targets:**
- Nostream: <400MB
- Dassie: <450MB

**Techniques:**
1. **Alpine base**: `node:22-alpine` vs `node:22` saves 600MB
2. **Multi-stage**: Don't include build tools in production
3. **pnpm**: Better dependency deduplication than npm
4. **Prune dev deps**: Only install production dependencies in final stage
5. **.dockerignore**: Exclude docs, tests, .git from build context

**Measurement:**
```bash
docker images --format "table {{.Repository}}\t{{.Size}}"
# nostream-ilp  380MB ✓
# dassie-node   420MB ✓
```

[Source: Docker image optimization guide]

---

### Docker Networking

**Service Discovery:**

Docker Compose creates a bridge network `nostream-ilp` where services can reach each other by name:

- `nostream` → `http://dassie:7768` (not localhost!)
- `nostream` → `postgresql://nostream-db:5432`
- `nostream` → `redis://nostream-cache:6379`

**Port Mapping:**
- Internal: Container port (e.g., 8008)
- External: Host port (e.g., 8008:8008)
- Only map ports you need to access from host

[Source: docker-compose.yml, Docker networking docs]

---

### Health Checks

**Purpose:**
- Ensure service is ready before marking as healthy
- Used by `depends_on: { condition: service_healthy }`
- Restart unhealthy containers

**Implementation:**
```dockerfile
HEALTHCHECK --interval=30s --timeout=10s --retries=3 --start-period=60s \
  CMD curl -f http://localhost:8008/health || exit 1
```

Parameters:
- `interval`: Check every 30s
- `timeout`: Fail if check takes >10s
- `retries`: Mark unhealthy after 3 failures
- `start-period`: Grace period on startup (60s)

[Source: Dockerfile reference, health checks]

---

### pnpm Workspace in Docker

**Challenge:**
- pnpm workspaces use symlinks
- Docker doesn't preserve symlinks well

**Solution:**
- Install all dependencies in deps stage
- Use `--filter app-nostream...` to install package + its workspace deps
- Copy node_modules as-is (includes resolved symlinks)

**Example:**
```dockerfile
# This installs app-nostream AND lib-payment-types (its workspace dep)
RUN pnpm install --frozen-lockfile --filter app-nostream...
```

[Source: pnpm Docker documentation]

---

### Environment Variables

**Required for Both Services:**

| Variable | Service | Purpose |
|----------|---------|---------|
| `SECRET` | Nostream | Session encryption |
| `DB_PASSWORD` | Nostream | PostgreSQL auth |
| `REDIS_PASSWORD` | Nostream | Redis auth |
| `DASSIE_RPC_TOKEN` | Both | RPC authentication |
| `SETTLEMENT_*` | Dassie | Settlement modules config |

**Injection Methods:**
1. `.env` file (development)
2. Environment variables (production)
3. Docker secrets (Swarm mode)
4. Akash SDL env section (Akash deployment)

[Source: docker-compose.yml, .env.example]

---

### Testing Strategy

**Unit Tests:**
- No new unit tests (no application logic)

**Integration Tests:**
- Test Docker build: `docker build` succeeds
- Test Docker Compose: `docker-compose up` starts all services
- Test health checks: All containers report healthy
- Test networking: Nostream can reach Dassie RPC

**Manual Tests:**
- Build images: `./scripts/docker-build.sh`
- Start stack: `docker-compose up -d`
- Check logs: `docker-compose logs -f`
- Verify communication: Check Nostream logs for Dassie connection
- Stop stack: `docker-compose down`

[Source: test/integration/docker-services.spec.ts]

---

### Dependencies

**Story Dependencies:**
- ✅ Story 2.10 complete (Monorepo structure)
- ✅ Story 2.11 complete (Dassie integration) - or can be done in parallel

**Blocking Stories:**
- Story 2.13: Update Akash Deployment (needs Docker images from this story)

**Docker Dependencies:**
- Docker Engine 24.x+
- Docker Compose 2.x+
- pnpm 8.x+ (for local builds)

[Source: Epic 2 PRD]

---

### Security Considerations

**Image Security:**
- Use official `node:22-alpine` base (smaller attack surface)
- Run as non-root user (`USER node`)
- Don't include secrets in image (use env vars)
- Scan images: `docker scan nostream-ilp:latest`

**Runtime Security:**
- Read-only root filesystem (add to docker-compose if needed)
- Drop capabilities (add security_opt if needed)
- Resource limits (memory, CPU)

**Secret Management:**
- Never hardcode secrets in Dockerfile
- Use environment variables
- Consider Docker secrets for Swarm mode
- Rotate secrets regularly

[Source: docs/architecture/security-architecture.md]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-11 | 1.0 | Initial story creation for Docker images | Sarah (PO) |

---

## Testing

```bash
# Build images
pnpm docker:build

# Verify images exist
docker images | grep -E "nostream-ilp|dassie-node"

# Start stack
docker-compose up -d

# Check health
docker ps
docker inspect --format='{{.State.Health.Status}}' nostream-ilp
docker inspect --format='{{.State.Health.Status}}' dassie-node

# Check logs
docker-compose logs nostream
docker-compose logs dassie

# Test communication
curl http://localhost:8008/health
curl http://localhost:7768/health

# Stop
docker-compose down
```

**Success Criteria:**
- ✅ Both images build successfully
- ✅ Image sizes <500MB each
- ✅ Services start and become healthy
- ✅ Nostream connects to Dassie RPC
- ✅ Health checks pass
- ✅ No errors in logs

---

## QA Results

_To be filled by QA Agent_
