# Story 1.2: Create Dassie RPC Client for Nostream

## Status

Approved

## Story

**As a** developer,
**I want** a WebSocket RPC client for calling Dassie ILP node,
**so that** Nostream can verify payment claims and query balances.

## Acceptance Criteria

1. New module created: `src/services/payment/dassie-client.ts` (note: Epic PRD references `src/integrations/` but architecture specifies `src/services/payment/` which is the canonical location)
2. Uses @trpc/client to connect to Dassie RPC:
   ```typescript
   import { createTRPCProxyClient, createWSClient } from '@trpc/client'
   import type { AppRouter } from '@dassie/app-dassie'

   const wsClient = createWSClient({
     url: process.env.DASSIE_RPC_URL || 'ws://localhost:5000/trpc'
   })

   export const dassieRpc = createTRPCProxyClient<AppRouter>({
     transport: wsClient
   })
   ```
3. Wrapper methods for common operations:
   - `getBalances() -> Promise<CurrencyBalances>` (wraps `ledger.getBalance` for multiple currencies)
   - `subscribeToBalance(callback)` (wraps `ledger.subscribeToAccount`)
   - `verifyPaymentClaim(claim)` (calls custom `payment.verifyPaymentClaim`)
   - `convertToAKT(currency, amount)` (calls custom `payment.convertToAKT`)
   - `claimChannels(currency?)` (calls custom `payment.claimAllChannels`)
   - `getRoutingStats()` (calls custom `payment.getRoutingStats`)
   Note: Custom payment.* endpoints must be added to Dassie in Epic 2; for Story 1.2, implement wrappers with proper error handling for missing endpoints
4. WebSocket reconnection logic (auto-reconnect on disconnect)
5. Error handling with typed error responses
6. Unit tests with mocked RPC responses
7. Integration test against real Dassie node

## Tasks / Subtasks

- [ ] Task 1: Install tRPC client dependencies (AC: 2)
  - [ ] Install @trpc/client: `pnpm add @trpc/client`
  - [ ] Install ws (WebSocket library): `pnpm add ws` and `pnpm add -D @types/ws`
  - [ ] Verify Dassie provides AppRouter type exports (check @dassie/app-dassie package)
  - [ ] Document dependency availability in MIGRATION.md

- [ ] Task 1.5: Create AppRouter type stub if Dassie types unavailable (AC: 2)
  - [ ] Check if @dassie/app-dassie exports AppRouter type
  - [ ] If not available, create `src/types/dassie-router.stub.ts` with minimal AppRouter interface:
    ```typescript
    // Stub type for Dassie AppRouter until Epic 2 Dassie fork is complete
    export interface AppRouter {
      ledger: {
        getBalance: { query: (params: { accountPath: string }) => Promise<{ balance: bigint }> };
        subscribeToAccount: { subscribe: (params: { accountPath: string }) => any };
      };
      payment: {
        verifyPaymentClaim: { query: (claim: any) => Promise<{ valid: boolean; error?: string }> };
        convertToAKT: { mutate: (params: any) => Promise<any> };
        claimAllChannels: { mutate: (params: any) => Promise<any> };
        getRoutingStats: { query: () => Promise<any> };
      };
    }
    ```
  - [ ] Update dassie-client.ts to import from stub: `import type { AppRouter } from '@/types/dassie-router.stub'`
  - [ ] Add TODO comment: "Replace with real AppRouter from @dassie/app-dassie after Epic 2"
  - [ ] Document stub creation in MIGRATION.md

- [ ] Task 2: Create dassie-client module structure (AC: 1, 2)
  - [ ] Create directory: `src/services/payment/`
  - [ ] Create file: `src/services/payment/dassie-client.ts`
  - [ ] Import tRPC dependencies: `@trpc/client`, `createWSClient`, `createTRPCProxyClient`
  - [ ] Define configuration interface for RPC URL and connection options
  - [ ] Export singleton client instance or factory function

- [ ] Task 3: Implement basic tRPC WebSocket client connection (AC: 2, 4)
  - [ ] Create WebSocket client with `createWSClient({ url: DASSIE_RPC_URL })`
  - [ ] Add environment variable: `DASSIE_RPC_URL` (default: `ws://localhost:5000/trpc`)
  - [ ] Implement WebSocket reconnection logic (aligned with architecture error-handling-resilience.md):
    - `retryDelayMs: 100` (initial retry delay, matching architecture)
    - `maxRetries: Infinity` (always retry for connection)
    - Exponential backoff: multiply by 2 each attempt
    - `maxDelayMs: 30000` (max 30 second delay)
    - Add jitter (10% random variance) to prevent thundering herd
  - [ ] Add connection state tracking (CONNECTING, CONNECTED, DISCONNECTED, RECONNECTING)
  - [ ] Emit connection state change events for monitoring

- [ ] Task 3.5: Implement graceful handling for missing Dassie endpoints (AC: 3)
  - [ ] Wrap all RPC calls in try-catch to detect missing endpoints
  - [ ] For custom payment.* endpoints, check if method exists before calling
  - [ ] If endpoint missing (404/method not found), log warning and return placeholder response:
    ```typescript
    if (!dassieRpc.payment?.verifyPaymentClaim) {
      logger.warn('payment.verifyPaymentClaim endpoint not available - Epic 2 pending');
      return { valid: false, error: 'payment-verification-unavailable' };
    }
    ```
  - [ ] Document missing endpoints in MIGRATION.md for Epic 2 implementation
  - [ ] Add feature flag: `DASSIE_PAYMENT_ENDPOINTS_AVAILABLE` (default: false)
  - [ ] Unit tests should mock all endpoints regardless of availability

- [ ] Task 4: Implement wrapper method: getBalances() (AC: 3)
  - [ ] Define CurrencyBalances TypeScript interface:
    ```typescript
    interface CurrencyBalances {
      btc_sats: bigint;
      base_wei: bigint;
      akt_uakt: bigint;
      xrp_drops: bigint;
    }
    ```
  - [ ] Implement `async getBalances(): Promise<CurrencyBalances>`
  - [ ] Call Dassie RPC using correct endpoint: `dassieRpc.ledger.getBalance.query({ accountPath })`
  - [ ] Query balances for all 4 currencies using account paths:
    - `btc:assets/settlement` or `btc:revenue/relay-fees`
    - `base:assets/settlement` or `base:revenue/relay-fees`
    - `akt:assets/settlement` or `akt:revenue/relay-fees`
    - `xrp:assets/settlement` or `xrp:revenue/relay-fees`
  - [ ] Aggregate results into CurrencyBalances object
  - [ ] Add error handling for RPC failures with retryWithBackoff (max 3 attempts)

- [ ] Task 5: Implement wrapper method: subscribeToBalance() (AC: 3)
  - [ ] Implement `subscribeToBalance(callback: (balance: bigint) => void): Subscription`
  - [ ] Use Dassie RPC subscription: `dassieRpc.ledger.subscribeToAccount.subscribe({ accountPath })`
  - [ ] Support subscribing to specific currency account paths
  - [ ] Return unsubscribe function to caller
  - [ ] Handle subscription errors and reconnection

- [ ] Task 6: Implement wrapper method: verifyPaymentClaim() (AC: 3)
  - [ ] Define PaymentClaim TypeScript interface (defined in this story for use by Story 1.3 and beyond):
    ```typescript
    // src/types/payment-claim.ts
    export interface PaymentClaim {
      channelId: string;
      amountSats: number;
      nonce: number;
      signature: string;
      currency: 'BTC' | 'BASE' | 'AKT' | 'XRP';
    }
    ```
  - [ ] Note: This interface aligns with architecture data-models.md and will be used by Story 1.3's tag parsing
  - [ ] Implement `async verifyPaymentClaim(claim: PaymentClaim): Promise<{ valid: boolean; error?: string }>`
  - [ ] Call Dassie RPC: `dassieRpc.payment.verifyPaymentClaim.query(claim)` (custom endpoint from Epic 2)
  - [ ] Map Dassie response to standardized { valid, error } format
  - [ ] Add timeout handling (5 second timeout for verification)
  - [ ] If endpoint not available (Epic 2 pending), return placeholder per Task 3.5

- [ ] Task 7: Implement wrapper methods: convertToAKT(), claimChannels(), getRoutingStats() (AC: 3)
  - [ ] Implement `async convertToAKT(currency, amount): Promise<ConversionResult>`
  - [ ] Call Dassie RPC: `dassieRpc.payment.convertToAKT.mutate({ amount, fromCurrency })`
  - [ ] Implement `async claimChannels(currency?: string): Promise<ClaimResult[]>`
  - [ ] Call Dassie RPC: `dassieRpc.payment.claimAllChannels.mutate({ currency })`
  - [ ] Implement `async getRoutingStats(): Promise<RoutingStats>`
  - [ ] Call Dassie RPC: `dassieRpc.payment.getRoutingStats.query()`
  - [ ] Define TypeScript interfaces for return types

- [ ] Task 8: Implement comprehensive error handling (AC: 5)
  - [ ] Create custom error classes:
    - `DassieConnectionError` - WebSocket connection failures
    - `DassieRPCError` - RPC call failures
    - `DassieTimeoutError` - RPC timeout
  - [ ] Wrap all RPC calls in try-catch blocks
  - [ ] Add structured logging with Pino for all errors
  - [ ] Implement error type detection (transient vs permanent)
  - [ ] Add retry logic for transient errors (using retryWithBackoff from architecture)

- [ ] Task 9: Add connection lifecycle management (AC: 4)
  - [ ] Implement `connect()` method to explicitly establish connection
  - [ ] Implement `disconnect()` method for graceful shutdown
  - [ ] Add `isConnected()` status check method
  - [ ] Emit events: 'connected', 'disconnected', 'reconnecting', 'error'
  - [ ] Add connection health monitoring (ping/pong heartbeat)
  - [ ] Implement graceful degradation when Dassie unavailable

- [ ] Task 10: Write unit tests with mocked RPC responses (AC: 6)
  - [ ] Create test file: `test/unit/services/payment/dassie-client.spec.ts`
  - [ ] Mock @trpc/client using Vitest mocks
  - [ ] Test getBalances() returns correct CurrencyBalances structure
  - [ ] Test verifyPaymentClaim() with valid and invalid claims
  - [ ] Test WebSocket reconnection logic
  - [ ] Test error handling for all wrapper methods
  - [ ] Test subscription cleanup on disconnect
  - [ ] Aim for 80%+ code coverage

- [ ] Task 11: Write integration test against real Dassie node (AC: 7)
  - [ ] Create test file: `test/integration/dassie-rpc.test.ts`
  - [ ] Use Testcontainers to spin up Dassie Docker container (if available)
  - [ ] If Testcontainers not available or Dassie container doesn't exist, mark test as `test.skip()` with comment:
    ```typescript
    test.skip('Integration test requires Dassie container - manual testing required', () => {
      // See TESTING.md for manual test procedure
    });
    ```
  - [ ] Test real RPC connection establishment
  - [ ] Test actual balance query against running Dassie node (use ledger.getBalance)
  - [ ] Test payment claim verification (expect placeholder response if payment.* endpoints not available)
  - [ ] Test reconnection after simulated network failure (kill/restart Dassie)
  - [ ] Clean up test containers after test completion

- [ ] Task 11.5: Document manual integration test procedure (AC: 7 fallback)
  - [ ] Create or update `TESTING.md` with manual integration test steps:
    1. Start Dassie locally: `cd ../dassie && pnpm run dev`
    2. Verify Dassie RPC available: `curl http://localhost:5000/health`
    3. Run Nostream integration test: `pnpm vitest run test/integration/dassie-rpc.test.ts`
    4. Expected results:
       - Connection establishes successfully
       - `ledger.getBalance` returns balance (may be 0)
       - `payment.*` methods return "endpoint not available" errors (until Epic 2)
       - Reconnection works after Dassie restart
    5. If Dassie not available, integration test can be deferred to Story 1.4 when full payment flow is testable
  - [ ] Document in story completion notes which test approach was used

- [ ] Task 12: Add monitoring and logging (Story enhancement)
  - [ ] Log all RPC calls with structured logging (method, params, duration)
  - [ ] Add metrics for RPC call latency
  - [ ] Add metrics for connection uptime/downtime
  - [ ] Log connection state transitions
  - [ ] Add debug logging for all WebSocket events (open, close, message, error)

- [ ] Task 13: Document dassie-client usage (Story enhancement)
  - [ ] Add JSDoc comments to all public methods
  - [ ] Create usage examples in comments
  - [ ] Document error types and how to handle them
  - [ ] Document environment variables: DASSIE_RPC_URL
  - [ ] Add notes about Dassie RPC API requirements (which endpoints must exist)

- [ ] Task 14: Update project configuration (Story enhancement)
  - [ ] Add DASSIE_RPC_URL to `.env.example`
  - [ ] Update `.nostr/settings.yaml` with Dassie configuration section
  - [ ] Document Dassie connection requirements in README.md
  - [ ] Add troubleshooting section for common connection issues

## Dev Notes

### Prerequisites and Story Dependencies

**Required**: Story 1.1 must be completed before starting Story 1.2.

**Story 1.1 Completion Checklist**:
- ✅ Nostream forked to `nostream-ilp` repository
- ✅ Payment processors removed (ZEBEDEE, Nodeless, OpenNode, LNbits)
- ✅ Migrated from npm to pnpm
- ✅ Migrated from Mocha to Vitest
- ✅ All baseline tests passing
- ✅ Project structure exists: `src/`, `test/`, `package.json`, `vitest.config.ts`

**Verification Steps Before Starting Story 1.2**:
1. Verify forked repository exists and is cloned locally
2. Run `pnpm install` successfully
3. Run `pnpm vitest run` and confirm tests pass
4. Verify `src/` directory exists with Nostream source code
5. Check `docs/stories/1.1.story.md` status is "Done"

**If Story 1.1 Not Complete**:
- Current repository state: No `src/` directory detected (per validation)
- Action: Complete Story 1.1 first, or document decision to skip fork and start fresh
- This story cannot proceed without base Nostream codebase

[Source: docs/stories/1.1.story.md status check, project structure verification]

---

### Previous Story Insights

From Story 1.1:
- Successfully migrated from npm to pnpm (now using pnpm 8.x)
- Successfully migrated from Mocha to Vitest (test framework aligned)
- TypeScript 5.3.3 installed and working
- Payment processor infrastructure removed cleanly
- NullPaymentsProcessor pattern preserved for future ILP integration
- Vitest configuration at `vitest.config.ts` is ready for new tests

[Source: docs/stories/1.1.story.md - Dev Agent Record]

### Project Context

This story builds the bridge between Nostream (Nostr relay) and Dassie (ILP node) by creating a type-safe tRPC client. This client will be the foundation for payment verification in Story 1.4. The client must handle network failures gracefully since Dassie and Nostream run in separate containers.

[Source: docs/prd/epic-1-nostream-fork-ilp-integration.md]

### Technology Stack for This Story

**Core Dependencies:**
- **tRPC Client**: `@trpc/client` v10.x - Type-safe RPC framework
- **WebSocket**: `ws` v8.x - WebSocket client library
- **TypeScript**: 5.3+ (already installed in Story 1.1)
- **Testing**: Vitest 1.x (already configured in Story 1.1)
- **Logging**: Pino 8.x (Nostream standard)

**Dassie Integration:**
- **AppRouter Type**: Expected from `@dassie/app-dassie` package
- **RPC Endpoint**: `ws://dassie:5000/trpc` (default, configurable)
- **RPC Protocol**: tRPC over WebSocket

[Source: docs/architecture/tech-stack.md]

### Data Models

**PaymentClaim** (from Story 1.3, preview for this story):
```typescript
interface PaymentClaim {
  channelId: string;      // Blockchain-specific channel identifier
  amountSats: number;     // Payment amount in satoshis
  nonce: number;          // Monotonically increasing counter
  signature: string;      // Hex-encoded cryptographic signature
  currency: 'BTC' | 'BASE' | 'AKT' | 'XRP';
}
```

**CurrencyBalances** (return type for getBalances()):
```typescript
interface CurrencyBalances {
  btc_sats: bigint;       // Bitcoin balance in satoshis
  base_wei: bigint;       // Base L2 balance in wei
  akt_uakt: bigint;       // Akash balance in uakt
  xrp_drops: bigint;      // XRP balance in drops
}
```

[Source: docs/architecture/data-models.md#paymentclaim]

### API Specifications

**Dassie RPC Endpoints** (Custom endpoints that must be added to Dassie):

1. **payment.verifyPaymentClaim** (Query)
   - Input: `{ channelId, amountSats, nonce, signature, currency }`
   - Output: `{ valid: boolean; error?: string }`
   - Purpose: Verify payment claim validity

2. **payment.convertToAKT** (Mutation)
   - Input: `{ amount, fromCurrency, slippageTolerance? }`
   - Output: `{ success, amountAKT, exchangeRate, transactionId }`
   - Purpose: Convert revenue to AKT for Akash bill payment

3. **ledger.getBalance** (Query)
   - Input: `{ accountPath: string }`
   - Output: `{ balance: bigint; accountPath: string; lastUpdated: number }`
   - Purpose: Get balance for a ledger account

4. **ledger.subscribeToAccount** (Subscription)
   - Input: `{ accountPath: string }`
   - Output (stream): `{ balance: bigint; delta: bigint; timestamp: number; reason: string }`
   - Purpose: Real-time balance updates

[Source: docs/architecture/api-specifications.md#dassie-rpc-api-trpc]

### File Locations and Naming Conventions

**New Files to Create:**
- `src/services/payment/dassie-client.ts` - Main RPC client implementation
- `test/unit/services/payment/dassie-client.spec.ts` - Unit tests
- `test/integration/dassie-rpc.test.ts` - Integration tests

**Project Structure Alignment:**
- Follows documented structure: `src/services/payment/` directory
- Aligns with Nostream's existing service pattern
- Test files mirror source structure

[Source: docs/architecture/source-tree-structure.md#nostream-ilp-repository-layout]

### Error Handling and Resilience

**Error Classification:**

1. **Transient Errors (Retry):**
   - Dassie RPC connection lost
   - WebSocket timeout
   - Temporary network failure

2. **Permanent Errors (Fail Fast):**
   - Invalid AppRouter type (missing Dassie endpoint)
   - Authentication failure (if RPC requires auth)
   - Invalid method call (typo in RPC method name)

**Retry Strategy:**
- Use exponential backoff with jitter (from architecture)
- Max attempts: 3 for RPC calls, Infinity for reconnection
- Initial delay: 100ms, max delay: 30s
- Implement using `retryWithBackoff` utility pattern

**Circuit Breaker:**
- Not required for this story (Dassie client only)
- Will be implemented in Story 1.7 for relay-wide degraded mode

[Source: docs/architecture/error-handling-resilience.md]

### Security Considerations

**Dassie RPC Authentication:**
- Story assumes Dassie RPC is on private container network (no authentication needed)
- If authentication required, add token-based auth to WebSocket connection
- Environment variable: `DASSIE_RPC_TOKEN` (optional)

**Data Validation:**
- Validate all RPC responses match expected schema
- Don't trust Dassie RPC implicitly (defense in depth)
- Log all validation failures

**Network Security:**
- Use `ws://` for local container network (Nostream ↔ Dassie)
- Use `wss://` if Dassie is remote (production deployment)
- Container network isolation prevents external access to Dassie RPC

[Source: docs/architecture/security-architecture.md#authentication-authorization]

### Testing Requirements

**Unit Testing:**
- Framework: Vitest 1.x (configured in Story 1.1)
- Mock Strategy: Mock @trpc/client and ws library using `vi.mock()`
- Coverage Target: 80%+ for dassie-client.ts
- Test all wrapper methods with both success and failure scenarios

**Integration Testing:**
- Requires running Dassie instance
- Options:
  1. Use Testcontainers to spin up Dassie Docker container (preferred)
  2. Manual test against local Dassie dev instance (fallback)
- Test real RPC calls and WebSocket reconnection

**Test Execution:**
- `pnpm vitest run test/unit/services/payment/dassie-client.spec.ts`
- `pnpm vitest run test/integration/dassie-rpc.test.ts`

[Source: docs/architecture/tech-stack.md#technology-stack-table]

### Known Constraints and Dependencies

**Blocking Dependencies:**
- **Dassie AppRouter Type**: Story assumes Dassie exports AppRouter type from `@dassie/app-dassie`
  - If not available, create local type stub as placeholder
  - Document missing types in MIGRATION.md
- **Dassie RPC Endpoints**: Story requires Dassie to implement custom payment.* endpoints
  - These endpoints may not exist in upstream Dassie yet
  - May need to fork Dassie and add endpoints (Epic 2 scope)
  - For now, document required endpoints and test with mocks

**Non-Blocking:**
- Integration test can be manual if Testcontainers not feasible
- Authentication can be added later if Dassie requires it

**Technical Debt:**
- If AppRouter type not available, create stub and mark as TODO for Epic 2

### Project Structure Notes

The story aligns with the documented architecture:
- New module at `src/services/payment/dassie-client.ts` matches source tree structure
- Follows separation of concerns (client wrapper separate from business logic)
- Tests mirror source structure (`test/unit/services/payment/`)

No structural conflicts identified.

[Source: docs/architecture/source-tree-structure.md]

---

## Testing

### Testing Standards

**Framework:** Vitest 1.x (configured in Story 1.1)
**Test Organization:**
- Unit tests: `test/unit/services/payment/dassie-client.spec.ts`
- Integration tests: `test/integration/dassie-rpc.test.ts`

**Coverage Requirements:**
- Target: 80%+ for dassie-client.ts
- All public methods must have tests
- Error paths must be tested

**Testing Commands:**
```bash
pnpm test                                  # Run all tests
pnpm vitest run test/unit/services/       # Unit tests only
pnpm vitest run test/integration/         # Integration tests only
pnpm vitest run --coverage                 # With coverage report
```

[Source: docs/architecture/tech-stack.md]

### Story-Specific Testing Requirements

1. **Unit Tests (Mocked RPC):**
   - Mock @trpc/client using `vi.mock('@trpc/client')`
   - Test all wrapper methods: getBalances(), verifyPaymentClaim(), etc.
   - Test error handling: connection failures, timeout, invalid responses
   - Test reconnection logic: exponential backoff, max retries
   - Test subscription management: subscribe, unsubscribe, cleanup

2. **Integration Tests (Real Dassie):**
   - Spin up Dassie node using Testcontainers (if available)
   - Test real WebSocket connection to Dassie RPC
   - Test actual RPC calls return expected data structures
   - Test reconnection after simulated network failure
   - Cleanup: Stop Dassie container after tests

3. **Manual Testing (Fallback):**
   - If Testcontainers not feasible, document manual test procedure
   - Steps: Start Dassie locally, run integration test, verify logs

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-25 | 1.0 | Initial story creation for Epic 1 Story 2 | Claude Code |
| 2025-11-25 | 1.1 | Validation remediation: Fixed file path inconsistencies (AC #1), corrected Dassie RPC endpoint names (ledger.getBalance, ledger.subscribeToAccount), fixed default RPC URL, added Task 1.5 for AppRouter stub creation, added Task 3.5 for missing endpoint handling, aligned retry config with architecture, clarified PaymentClaim interface ownership, added Task 11.5 for integration test fallback, added Story 1.1 prerequisite verification | Claude Code |

---

## Dev Agent Record

*(This section will be populated by the development agent during implementation)*

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

---

## QA Results

*(This section will be populated by QA agent after development completion)*
