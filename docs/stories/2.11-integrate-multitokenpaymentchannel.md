# Story 2.11: Integrate MultiTokenPaymentChannelFactory with Dassie

## Status

Draft

## Story

**As a** developer,
**I want** Dassie to use MultiTokenPaymentChannelFactory for Base/Cronos settlements,
**so that** users can pay the relay with multiple ERC-20 tokens on different L2 chains.

## Acceptance Criteria

1. Dassie Cosmos settlement module integrated with MultiTokenPaymentChannelFactory contract
2. Support for Base L2 (Sepolia testnet and mainnet)
3. Support for Cronos (testnet and mainnet)
4. Contract interaction via viem library
5. Open channel function: Creates channel with ERC-20 token or native ETH
6. Verify claim function: Validates off-chain signed payment claims
7. Close channel function: Settles final claim on-chain
8. RPC endpoint added: `verifyPaymentClaim` accepts claims for BASE/CRONOS
9. Integration tests with deployed MultiTokenPaymentChannelFactory
10. Documentation: How to configure Base/Cronos settlement

## Tasks / Subtasks

- [ ] Task 1: Create Base L2 Settlement Module (AC: 1, 2, 4)
  - [ ] Create `packages/app-dassie/src/settlement/base/` directory
  - [ ] Create `base-settlement-module.ts`:
    ```typescript
    import { createSettlementModule } from '../settlement-module-factory'
    import { http, createPublicClient, createWalletClient } from 'viem'
    import { base, baseSepolia } from 'viem/chains'

    export const createBaseSettlementModule = (config: BaseConfig) => {
      const chain = config.network === 'mainnet' ? base : baseSepolia
      const publicClient = createPublicClient({
        chain,
        transport: http(config.rpcUrl)
      })
      // ...settlement logic
    }
    ```
  - [ ] Implement SettlementSchemeModule interface from Dassie
  - [ ] Load contract ABI from `packages/lib-contracts/artifacts/`
  - [ ] Configure RPC endpoint from environment (SETTLEMENT_BASE_RPC_URL)

- [ ] Task 2: Implement Open Channel Function (AC: 5)
  - [ ] Add `openChannel` method to Base settlement module:
    ```typescript
    async openChannel(params: {
      recipient: Address,
      token: Address,  // ERC-20 address or 0x0 for ETH
      amount: bigint,
      expiration: number
    }): Promise<ChannelId> {
      const txHash = await walletClient.writeContract({
        address: config.factoryAddress,
        abi: MultiTokenFactoryABI,
        functionName: 'openChannel',
        args: [params.recipient, params.token, params.expiration],
        value: params.token === '0x0' ? params.amount : 0n
      })

      // Wait for confirmation
      const receipt = await publicClient.waitForTransactionReceipt({ hash: txHash })

      // Extract channelId from event
      const channelId = parseChannelOpenedEvent(receipt.logs)

      // Store channel state in Dassie internal ledger
      await this.storeChannelState(channelId, params)

      return channelId
    }
    ```
  - [ ] Handle ERC-20 token approval (if token !== ETH)
  - [ ] Emit Dassie settlement event when channel opens
  - [ ] Update internal ledger with channel balance

- [ ] Task 3: Implement Verify Claim Function (AC: 6)
  - [ ] Add `verifyClaim` method to settlement module:
    ```typescript
    async verifyClaim(claim: PaymentClaim): Promise<VerificationResult> {
      // 1. Look up channel state from internal ledger
      const channel = await this.getChannelState(claim.channelId)

      if (!channel) {
        return { valid: false, reason: 'channel-not-found' }
      }

      // 2. Verify signature (off-chain)
      const message = encodeClaim(claim)
      const recoveredSigner = await recoverMessageAddress({
        message,
        signature: claim.signature as Hex
      })

      if (recoveredSigner.toLowerCase() !== channel.sender.toLowerCase()) {
        return { valid: false, reason: 'invalid-signature' }
      }

      // 3. Verify nonce monotonicity
      if (claim.nonce <= channel.lastNonce) {
        return { valid: false, reason: 'nonce-not-monotonic' }
      }

      // 4. Verify amount ≤ channel balance
      if (claim.amount > channel.balance) {
        return { valid: false, reason: 'insufficient-balance' }
      }

      // 5. Update channel state (highest nonce)
      await this.updateChannelState(claim.channelId, {
        lastNonce: claim.nonce,
        lastClaimAmount: claim.amount
      })

      return { valid: true, amount: claim.amount }
    }
    ```
  - [ ] Use viem's `recoverMessageAddress` for signature verification
  - [ ] Match contract's claim encoding format (EIP-712 or simple keccak256)
  - [ ] Update Dassie internal ledger with verified claim

- [ ] Task 4: Implement Close Channel Function (AC: 7)
  - [ ] Add `closeChannel` method:
    ```typescript
    async closeChannel(channelId: string, finalClaim: PaymentClaim): Promise<void> {
      // Get channel state
      const channel = await this.getChannelState(channelId)

      // Call contract closeChannel with final claim
      const txHash = await walletClient.writeContract({
        address: config.factoryAddress,
        abi: MultiTokenFactoryABI,
        functionName: 'closeChannel',
        args: [
          channelId,
          finalClaim.amount,
          finalClaim.nonce,
          finalClaim.signature
        ]
      })

      // Wait for settlement
      await publicClient.waitForTransactionReceipt({ hash: txHash })

      // Update internal ledger (mark channel as closed)
      await this.markChannelClosed(channelId, finalClaim.amount)

      // Emit settlement event
      this.emitSettlement(channelId, finalClaim.amount)
    }
    ```
  - [ ] Handle gas estimation and transaction failures
  - [ ] Verify settlement event emitted by contract
  - [ ] Update Dassie accounting (record settled revenue)

- [ ] Task 5: Add Cronos Settlement Module (AC: 3)
  - [ ] Create `packages/app-dassie/src/settlement/cronos/` directory
  - [ ] Copy Base settlement module structure
  - [ ] Update chain configuration:
    ```typescript
    import { cronos, cronosTestnet } from 'viem/chains'
    const chain = config.network === 'mainnet' ? cronos : cronosTestnet
    ```
  - [ ] Use Cronos-specific RPC endpoint (SETTLEMENT_CRONOS_RPC_URL)
  - [ ] Use deployed CronosPaymentChannel contract address
  - [ ] Same openChannel/verifyClaim/closeChannel logic

- [ ] Task 6: Create Payment Verification RPC Endpoint (AC: 8)
  - [ ] Add to `packages/app-dassie/src/rpc-server/routers/payment.ts`:
    ```typescript
    verifyPaymentClaim: authenticatedProcedure
      .input(z.object({
        channelId: z.string(),
        amount: z.string(),  // BigInt as string
        nonce: z.number(),
        signature: z.string(),  // hex
        currency: z.enum(['BTC', 'BASE', 'CRONOS', 'AKT', 'XRP'])
      }))
      .mutation(async ({ input, ctx }) => {
        // Route to appropriate settlement module
        const settlementModule = getSettlementModule(input.currency)

        const result = await settlementModule.verifyClaim({
          channelId: input.channelId,
          amount: BigInt(input.amount),
          nonce: input.nonce,
          signature: input.signature as Hex
        })

        return result  // { valid: boolean, reason?: string, amount?: string }
      })
    ```
  - [ ] Add currency routing logic (BASE → base module, CRONOS → cronos module)
  - [ ] Require RPC authentication (uses existing Dassie auth from Story 2.2)
  - [ ] Export in AppRouter type for Nostream tRPC client

- [ ] Task 7: Configure Environment Variables (AC: 10)
  - [ ] Add to `.env.example`:
    ```bash
    # Base L2 Settlement
    SETTLEMENT_BASE_ENABLED=true
    SETTLEMENT_BASE_NETWORK=sepolia  # or mainnet
    SETTLEMENT_BASE_RPC_URL=https://sepolia.base.org
    SETTLEMENT_BASE_FACTORY_ADDRESS=0x...  # MultiTokenPaymentChannelFactory
    SETTLEMENT_BASE_RELAY_PRIVATE_KEY=0x...  # Relay's private key

    # Cronos Settlement
    SETTLEMENT_CRONOS_ENABLED=true
    SETTLEMENT_CRONOS_NETWORK=testnet  # or mainnet
    SETTLEMENT_CRONOS_RPC_URL=https://evm-t3.cronos.org
    SETTLEMENT_CRONOS_FACTORY_ADDRESS=0x9Ec2d217b14e67cAbF86F20F4E7462D6d7bc7684
    SETTLEMENT_CRONOS_RELAY_PRIVATE_KEY=0x...
    ```
  - [ ] Load config in Dassie startup
  - [ ] Validate required vars present
  - [ ] Document in README

- [ ] Task 8: Add Contract ABI Integration (AC: 4)
  - [ ] Copy MultiTokenPaymentChannelFactory ABI from lib-contracts:
    ```typescript
    import factoryABI from '@nostream-ilp/lib-contracts/artifacts/MultiTokenPaymentChannelFactory.json'
    ```
  - [ ] Use workspace dependency to reference lib-contracts
  - [ ] Alternatively: Export ABI from lib-contracts package:
    ```typescript
    // packages/lib-contracts/src/abis.ts
    export { default as MultiTokenFactoryABI } from '../artifacts/.../MultiTokenPaymentChannelFactory.json'
    ```
  - [ ] Import in Dassie settlement modules

- [ ] Task 9: Integration Tests (AC: 9)
  - [ ] Create `packages/app-dassie/test/settlement/base-settlement.test.ts`:
    ```typescript
    describe('Base Settlement Module', () => {
      it('should open channel with ETH', async () => {
        const channel = await settlement.openChannel({
          recipient: relayAddress,
          token: '0x0',  // Native ETH
          amount: parseEther('0.01'),
          expiration: Math.floor(Date.now() / 1000) + 86400
        })
        expect(channel.channelId).toBeDefined()
      })

      it('should verify valid payment claim', async () => {
        const claim = await createSignedClaim(channelId, 1000n, 1)
        const result = await settlement.verifyClaim(claim)
        expect(result.valid).toBe(true)
      })

      it('should close channel and settle', async () => {
        const finalClaim = await createSignedClaim(channelId, 5000n, 5)
        await settlement.closeChannel(channelId, finalClaim)
        // Verify settlement recorded in ledger
      })
    })
    ```
  - [ ] Use Base Sepolia testnet (requires funded wallet)
  - [ ] Test with actual deployed MultiTokenPaymentChannelFactory
  - [ ] Mock tests for mainnet (no real funds)

- [ ] Task 10: Update Nostream Payment Client (AC: 8)
  - [ ] Update `packages/app-nostream/src/services/payment/dassie-client.ts`:
    ```typescript
    async verifyPaymentClaim(claim: PaymentClaim): Promise<boolean> {
      const result = await this.trpcClient.verifyPaymentClaim.mutate({
        channelId: claim.channelId,
        amount: claim.amount.toString(),
        nonce: claim.nonce,
        signature: claim.signature,
        currency: claim.currency  // 'BASE' or 'CRONOS'
      })

      return result.valid
    }
    ```
  - [ ] Add currency field to PaymentClaim interface (lib-payment-types)
  - [ ] Update event handler to extract currency from Nostr event tags
  - [ ] Test end-to-end: Nostr event → payment claim → Dassie verification

- [ ] Task 11: Documentation (AC: 10)
  - [ ] Create `docs/settlement/base-l2-settlement.md`:
    - How MultiTokenPaymentChannelFactory works
    - Supported tokens (ETH, ERC-20)
    - Opening channels
    - Verifying claims
    - Closing channels
    - Gas cost estimates
  - [ ] Create `docs/settlement/cronos-settlement.md` (similar structure)
  - [ ] Update `packages/app-dassie/README.md`:
    - Settlement module architecture
    - Adding new settlement modules
    - Environment configuration
  - [ ] Add examples to `docs/examples/`:
    - Opening a Base channel with ETH
    - Creating a signed payment claim
    - Closing a channel

## Dev Notes

### Architecture Context

**MultiTokenPaymentChannelFactory:**

This story integrates the deployed MultiTokenPaymentChannelFactory contract (from Epic 3) with Dassie's settlement layer.

**Contract Addresses:**

| Network | Contract | Address |
|---------|----------|---------|
| Cronos Mainnet | MultiTokenPaymentChannelFactory | `0x9Ec2d217b14e67cAbF86F20F4E7462D6d7bc7684` |
| Cronos Testnet | MultiTokenPaymentChannelFactory | `0x4b9e32389896C05A4CAfC41bE9dA6bB108a7dA72` |
| Base Mainnet | MultiTokenPaymentChannelFactory | TBD (deploy first) |
| Base Sepolia | MultiTokenPaymentChannelFactory | TBD (deploy first) |

[Source: README.md Deployed Contracts section]

**Contract Interface:**
```solidity
function openChannel(
    address recipient,
    address token,
    uint256 expiration
) external payable returns (bytes32 channelId);

function closeChannel(
    bytes32 channelId,
    uint256 claimAmount,
    uint256 nonce,
    bytes calldata signature
) external;

function getChannel(bytes32 channelId) external view returns (
    address sender,
    address recipient,
    address token,
    uint256 balance,
    uint256 nonce,
    uint256 expiration,
    bool closed
);
```

[Source: contracts/MultiTokenPaymentChannelFactory.sol]

---

### Dassie Settlement Module Interface

Dassie settlement modules must implement the `SettlementSchemeModule` interface:

```typescript
interface SettlementSchemeModule {
  // Initialize module with config
  initialize(config: SettlementConfig): Promise<void>

  // Open payment channel
  openChannel(params: OpenChannelParams): Promise<ChannelId>

  // Verify off-chain payment claim
  verifyClaim(claim: PaymentClaim): Promise<VerificationResult>

  // Close channel and settle on-chain
  closeChannel(channelId: ChannelId, finalClaim: PaymentClaim): Promise<void>

  // Get channel state
  getChannelState(channelId: ChannelId): Promise<ChannelState>
}
```

**Dassie Internal Ledger:**

Settlement modules interact with Dassie's internal double-entry ledger:

Account structure:
```
base:assets/settlement         # ETH/tokens held in contracts
base:assets/interledger/userA  # Credit owed to user A
base:liabilities/userA         # Revenue from user A
```

When claim verified:
```typescript
// Credit user's account (they paid us)
ledger.credit('base:liabilities/userA', claimAmount)
ledger.debit('base:assets/settlement', claimAmount)
```

[Source: Dassie documentation, internal ledger architecture]

---

### Payment Claim Structure

**Nostr Event Tag Format:**
```json
{
  "kind": 1,
  "tags": [
    ["payment", "base", "0xchannelId", "1000", "5", "0xsignature"]
  ],
  "content": "My paid event"
}
```

Tag format: `["payment", currency, channelId, amount, nonce, signature]`

**TypeScript Interface (lib-payment-types):**
```typescript
interface PaymentClaim {
  channelId: string      // bytes32 as hex
  amount: bigint         // Wei or token smallest unit
  nonce: number          // Monotonic counter
  signature: Hex         // ECDSA signature
  currency: Currency     // 'BTC' | 'BASE' | 'CRONOS' | 'AKT' | 'XRP'
}

type Currency = 'BTC' | 'BASE' | 'CRONOS' | 'AKT' | 'XRP'
```

[Source: src/services/payment/payment-claim-parser.ts]

---

### viem Library Integration

**Why viem?**
- Modern, TypeScript-first Ethereum library
- Better tree-shaking than ethers.js (smaller bundle)
- Type-safe contract interactions
- Built-in multicall support

**Basic Usage:**
```typescript
import { createPublicClient, createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { base } from 'viem/chains'

// Read-only client
const publicClient = createPublicClient({
  chain: base,
  transport: http('https://mainnet.base.org')
})

// Wallet client (for transactions)
const account = privateKeyToAccount(process.env.PRIVATE_KEY as Hex)
const walletClient = createWalletClient({
  account,
  chain: base,
  transport: http('https://mainnet.base.org')
})

// Contract interaction
const txHash = await walletClient.writeContract({
  address: factoryAddress,
  abi: MultiTokenFactoryABI,
  functionName: 'openChannel',
  args: [recipientAddress, tokenAddress, expiration],
  value: parseEther('0.01')
})
```

[Source: viem documentation]

---

### Signature Verification

**On-Chain (Contract):**
```solidity
bytes32 message = keccak256(abi.encodePacked(channelId, claimAmount, nonce));
bytes32 ethSignedMessage = message.toEthSignedMessageHash();
address signer = ethSignedMessage.recover(signature);
require(signer == sender, "Invalid signature");
```

**Off-Chain (Dassie):**
```typescript
import { recoverMessageAddress, keccak256, encodePacked } from 'viem'

const message = keccak256(encodePacked(
  ['bytes32', 'uint256', 'uint256'],
  [channelId, claimAmount, nonce]
))

const signer = await recoverMessageAddress({
  message: { raw: message },
  signature: claim.signature
})

if (signer.toLowerCase() !== channel.sender.toLowerCase()) {
  throw new Error('Invalid signature')
}
```

**Must match contract's encoding exactly!**

[Source: contracts/MultiTokenPaymentChannelFactory.sol, viem docs]

---

### Gas Cost Estimates

**Base L2 (Sepolia):**
- `openChannel`: ~100,000 gas (~$0.01 at 1 gwei)
- `closeChannel`: ~80,000 gas (~$0.008 at 1 gwei)

**Cronos:**
- `openChannel`: ~120,000 gas (~$0.003 at 5000 gwei, CRO cheap)
- `closeChannel`: ~90,000 gas (~$0.002 at 5000 gwei)

**Optimization:**
- Batch channel closures (close multiple channels in one transaction)
- Use multicall for reading channel states
- Only close channels when necessary (keep open for recurring users)

[Source: Hardhat gas reports from contract tests]

---

### Testing Strategy

**Unit Tests:**
- Mock viem clients (publicClient, walletClient)
- Test signature verification logic
- Test channel state management
- Test nonce validation

**Integration Tests (Testnet):**
- Requires funded wallet on Base Sepolia
- Deploy MultiTokenPaymentChannelFactory to Sepolia (if not exists)
- Test full flow: open → verify multiple claims → close
- Verify settlement events emitted
- Check final balances on-chain

**Contract Tests:**
- Already exist in lib-contracts/test/
- Ensure Dassie integration matches contract behavior

[Source: docs/architecture/testing-strategy.md]

---

### Dependencies

**Story Dependencies:**
- ✅ Story 2.10 complete (Dassie in monorepo)
- ✅ Epic 3 complete (MultiTokenPaymentChannelFactory deployed)
- ✅ Story 2.2 complete (RPC token auth) - if not, can be done in parallel

**NPM Dependencies to Add:**
```json
{
  "dependencies": {
    "viem": "^2.0.0"
  }
}
```

**Contract Dependencies:**
- MultiTokenPaymentChannelFactory deployed on Base Sepolia
- MultiTokenPaymentChannelFactory deployed on Cronos testnet (already done)

[Source: Epic 2 PRD, Story 2.10]

---

### Security Considerations

**Private Key Management:**
- Relay's private key must be stored securely
- Use environment variable, never hardcode
- Consider using KMS (AWS KMS, GCP KMS) for mainnet
- Rotate keys periodically

**Signature Replay Prevention:**
- Nonce must be monotonically increasing
- Store highest nonce in Dassie ledger
- Reject claims with nonce ≤ last verified nonce

**Channel Expiration:**
- Check channel.expiration before accepting claims
- Reject claims for expired channels
- Auto-close expired channels with highest verified claim

**Double-Spending:**
- Only accept claims with higher nonce than previous
- Update channel state immediately after verification
- Use database transactions to prevent race conditions

[Source: docs/architecture/security-architecture.md]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-11 | 1.0 | Initial story creation for MultiTokenPaymentChannelFactory integration | Sarah (PO) |

---

## Testing

```bash
# Run Dassie settlement tests
pnpm --filter app-dassie test settlement

# Run integration tests (requires testnet wallet)
BASE_PRIVATE_KEY=0x... pnpm --filter app-dassie test:integration

# Test RPC endpoint
curl -X POST http://localhost:7768/trpc/verifyPaymentClaim \
  -H "Content-Type: application/json" \
  -d '{
    "channelId": "0x...",
    "amount": "1000000000000000000",
    "nonce": 1,
    "signature": "0x...",
    "currency": "BASE"
  }'
```

**Success Criteria:**
- ✅ Can open channel on Base Sepolia
- ✅ Can verify payment claim off-chain
- ✅ Can close channel and receive settlement
- ✅ RPC endpoint returns correct verification results
- ✅ Integration tests pass on testnet
- ✅ Nostream can verify BASE/CRONOS claims via Dassie

---

## QA Results

_To be filled by QA Agent_
