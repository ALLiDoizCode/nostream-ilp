# Story 1.5: Add Pricing Configuration

## Status

Done

## Story

**As an** operator,
**I want** configurable pricing for relay operations,
**so that** I can set costs appropriate for economic sustainability.

## Acceptance Criteria

1. Environment variables added:
   - `PRICING_STORE_EVENT` (default: 10 sats)
   - `PRICING_DELIVER_EVENT` (default: 1 sat)
   - `PRICING_QUERY` (default: 5 sats)
   - `PRICING_FREE_TIER_EVENTS` (default: 0, set to e.g., 100 for free trial)
2. Pricing exposed in NIP-11 relay information document:
   ```json
   {
     "name": "Self-Sustaining Relay",
     "payments_url": "https://docs.example.com/payments",
     "fees": {
       "admission": [{ "amount": 10, "unit": "sat" }],
       "publication": [{ "amount": 10, "unit": "sat" }]
     }
   }
   ```
3. `calculateRequiredPayment(operation, event) -> number` function
4. Different pricing tiers by event kind (optional, configurable)
5. Documentation explaining pricing model
6. Unit tests for pricing calculations

## Tasks / Subtasks

- [ ] Task 1: Add pricing environment variables to configuration (AC: 1)
  - [ ] Add environment variables to `.env.example`:
    ```bash
    # Pricing Configuration (Story 1.5)
    PRICING_STORE_EVENT=10           # Satoshis per event stored
    PRICING_DELIVER_EVENT=1          # Satoshis per event delivered via REQ
    PRICING_QUERY=5                  # Satoshis per REQ subscription
    PRICING_FREE_TIER_EVENTS=0       # Free events per pubkey (0=disabled)

    # Per-Kind Pricing Overrides (optional, comma-separated)
    # Format: kind:amount (e.g., "1:10,30023:100,1063:500")
    PRICING_KIND_OVERRIDES=
    ```
  - [ ] Document variable meanings and default values
  - [ ] Note: Free tier logic is implemented in Story 1.6
  - [ ] Create `.env.local.example` for operator reference

- [ ] Task 2: Create pricing configuration module (AC: 1, 4)
  - [ ] Create new file: `src/services/payment/pricing-config.ts`
  - [ ] Define `PricingConfig` interface:
    ```typescript
    export interface PricingConfig {
      storeEvent: bigint              // Default cost to store event
      deliverEvent: bigint            // Cost per event delivered
      query: bigint                   // Cost per REQ subscription
      freeTierEvents: number          // Free events (Story 1.6)
      kindOverrides: Map<number, bigint>  // Per-kind pricing
    }
    ```
  - [ ] Implement `loadPricingConfig(): PricingConfig` function
  - [ ] Parse environment variables with fallback to defaults
  - [ ] Parse `PRICING_KIND_OVERRIDES` into Map (format: "1:10,30023:100")
  - [ ] Validate pricing values (must be non-negative, within reasonable limits)
  - [ ] Export singleton instance: `export const pricingConfig = loadPricingConfig()`
  - [ ] Add JSDoc documentation for all exports

- [ ] Task 3: Implement pricing calculator function (AC: 3, 4)
  - [ ] Create file: `src/services/payment/pricing-calculator.ts`
  - [ ] Implement `calculateRequiredPayment(operation: string, event?: Event): bigint`
  - [ ] Operation types: `'store'`, `'deliver'`, `'query'`
  - [ ] Pricing logic:
    - If operation is `'store'`:
      - Check if event kind has override in `pricingConfig.kindOverrides`
      - If override exists, return override amount
      - Else return `pricingConfig.storeEvent`
    - If operation is `'deliver'`: return `pricingConfig.deliverEvent`
    - If operation is `'query'`: return `pricingConfig.query`
    - Default: return 0 (no charge for unknown operations)
  - [ ] Handle edge cases: missing event, invalid operation type
  - [ ] Add unit tests for all operation types and kind overrides

- [ ] Task 4: Expose pricing in NIP-11 relay information document (AC: 2)
  - [ ] Locate NIP-11 endpoint handler (likely in `src/handlers/` or `src/routes/`)
  - [ ] Import pricing configuration: `import { pricingConfig } from '@/services/payment/pricing-config'`
  - [ ] Add `fees` object to NIP-11 response:
    ```typescript
    fees: {
      admission: [
        { amount: Number(pricingConfig.storeEvent), unit: 'sat' }
      ],
      publication: [
        { amount: Number(pricingConfig.storeEvent), unit: 'sat' }
      ],
      subscription: [
        { amount: Number(pricingConfig.query), unit: 'sat' }
      ]
    }
    ```
  - [ ] Add `payments_url` field linking to payment documentation
  - [ ] Include supported currencies: `supported_nips: [57]` (Lightning Zaps as ILP placeholder)
  - [ ] Test NIP-11 response with `curl http://localhost:port/` with Accept header

- [ ] Task 5: Integrate pricing calculator into EventMessageHandler (AC: 3)
  - [ ] Modify `calculateRequiredPayment()` in `event-message-handler.ts` (from Story 1.4)
  - [ ] Replace hardcoded default (10 sats) with call to pricing calculator:
    ```typescript
    import { calculateRequiredPayment } from '@/services/payment/pricing-calculator'

    private calculateRequiredPayment(event: Event): bigint {
      return calculateRequiredPayment('store', event)
    }
    ```
  - [ ] Remove old static default value logic
  - [ ] Ensure existing tests still pass with new pricing logic

- [ ] Task 6: Document pricing model and configuration (AC: 5)
  - [ ] Create documentation: `docs/operator-guide/pricing-configuration.md`
  - [ ] Explain pricing model:
    - Default pricing for all events
    - Per-kind pricing overrides for specialized content
    - Economic rationale (sustainability, spam prevention)
  - [ ] Provide example configurations:
    - Free relay (all prices set to 0)
    - Basic paid relay (10 sats per event)
    - Tiered pricing (1 sat for notes, 100 sats for articles, 500 sats for media)
  - [ ] Document how to calculate pricing based on costs:
    - Estimate storage cost per event (PostgreSQL, Arweave)
    - Estimate bandwidth cost per event delivery
    - Add profit margin for sustainability
  - [ ] Link to NIP-11 specification for context
  - [ ] Add troubleshooting section (pricing not applied, environment variables not loaded)

- [ ] Task 7: Add unit tests for pricing configuration (AC: 6)
  - [ ] Create test file: `test/unit/services/payment/pricing-config.spec.ts`
  - [ ] Test `loadPricingConfig()` with valid environment variables
  - [ ] Test default values when environment variables not set
  - [ ] Test `PRICING_KIND_OVERRIDES` parsing:
    - Valid format: "1:10,30023:100"
    - Invalid format: "invalid" (should log error, skip)
    - Empty string: "" (should result in empty Map)
  - [ ] Test validation of pricing values (negative values rejected)
  - [ ] Mock process.env for test isolation

- [ ] Task 8: Add unit tests for pricing calculator (AC: 6)
  - [ ] Create test file: `test/unit/services/payment/pricing-calculator.spec.ts`
  - [ ] Test `calculateRequiredPayment('store', event)`:
    - Event kind has override → returns override amount
    - Event kind no override → returns default storeEvent price
    - No event provided → returns default storeEvent price
  - [ ] Test `calculateRequiredPayment('deliver', event)`:
    - Returns `pricingConfig.deliverEvent`
  - [ ] Test `calculateRequiredPayment('query', event)`:
    - Returns `pricingConfig.query`
  - [ ] Test unknown operation type → returns 0
  - [ ] Test with multiple kind overrides (ensure correct kind matched)

- [ ] Task 9: Update MIGRATION.md with Story 1.5 changes (documentation)
  - [ ] Document new files:
    - `src/services/payment/pricing-config.ts`
    - `src/services/payment/pricing-calculator.ts`
    - `docs/operator-guide/pricing-configuration.md`
  - [ ] Document environment variables added to `.env.example`
  - [ ] Document modification to EventMessageHandler pricing logic
  - [ ] Document NIP-11 relay info changes (fees object)
  - [ ] Note integration points with Story 1.4 (payment verification)
  - [ ] Note placeholder for Story 1.6 (free tier logic)

- [ ] Task 10: Add JSDoc documentation to pricing modules (code quality)
  - [ ] Document `PricingConfig` interface with examples
  - [ ] Document `loadPricingConfig()` function:
    - Purpose: Load pricing from environment variables
    - Returns: Validated PricingConfig object
    - Throws: Never (defaults used on error)
  - [ ] Document `calculateRequiredPayment(operation, event?)` function:
    - Purpose: Calculate required payment for operation
    - Parameters: operation type, optional event for kind-based pricing
    - Returns: amount in satoshis (bigint)
    - Examples for each operation type

## Dev Notes

### Prerequisites and Story Dependencies

**Required**: Story 1.4 must be completed before starting Story 1.5.

**Story 1.4 Completion Status**: ✅ Done
- Payment verification implemented in EventMessageHandler
- `calculateRequiredPayment()` helper exists with hardcoded default (10 sats)
- Story 1.5 will enhance this with configurable pricing

**Story 1.6 Dependency**: Story 1.5 prepares configuration for Story 1.6 (Free Tier)
- `PRICING_FREE_TIER_EVENTS` environment variable added but not used yet
- Story 1.6 will implement free tier tracking and enforcement

[Source: docs/stories/1.4.story.md]

---

### Previous Story Insights

**From Story 1.4 (Payment Verification):**
- `calculateRequiredPayment(event: Event): bigint` method exists in EventMessageHandler
- Currently uses hardcoded default: 10n sats (bigint)
- Iterates through fee schedules in settings to match event kind
- Returns default if no fee schedule matches
- Story 1.5 will replace this logic with pricing calculator

**From Story 1.3 (Payment Claim Parser):**
- Payment amounts are in satoshis (standardized across currencies)
- Parser validates amount > 0, < 2^53
- Amounts stored as `number` in PaymentClaim interface

**From Story 1.2 (Dassie RPC Client):**
- Dassie verifies payment claims against channel balances
- Amounts in Dassie ledger use bigint for precision
- Story 1.5 pricing calculator returns bigint to match

**From Story 1.1 (Fork and Cleanup):**
- Existing settings system uses `.nostr/settings.yaml` (not present in current repo)
- FeeSchedule interface exists in `src/@types/settings.ts`
- Story 1.5 adds environment variable-based pricing as alternative to YAML

**Implications for Story 1.5:**
- Pricing calculator should return `bigint` to match existing types
- Environment variables preferred over YAML for operator simplicity
- Must maintain backward compatibility with existing fee schedule logic
- NIP-11 endpoint likely in `src/handlers/` or `src/routes/` (needs verification)

[Source: docs/stories/1.4.story.md - Dev Agent Record, src/@types/settings.ts]

---

### Technology Stack for This Story

**Core Dependencies** (already installed):
- **TypeScript**: 5.3+ (project standard)
- **Node.js**: 22.x LTS (runtime)
- **Vitest**: 1.x (unit testing)
- **Pino**: 8.x (logging for validation errors)

**No New Dependencies Required**: This story extends existing configuration and pricing logic.

[Source: docs/architecture/tech-stack.md]

---

### Data Models

**PricingConfig** (new interface for Story 1.5):
```typescript
interface PricingConfig {
  storeEvent: bigint              // Default cost to store event (satoshis)
  deliverEvent: bigint            // Cost per event delivered (satoshis)
  query: bigint                   // Cost per REQ subscription (satoshis)
  freeTierEvents: number          // Free events per pubkey (0=disabled, Story 1.6)
  kindOverrides: Map<number, bigint>  // Per-kind pricing overrides
}
```

**Example PricingConfig:**
```typescript
{
  storeEvent: 10n,                    // 10 sats per event
  deliverEvent: 1n,                   // 1 sat per delivery
  query: 5n,                          // 5 sats per query
  freeTierEvents: 0,                  // No free tier
  kindOverrides: new Map([
    [1, 10n],           // Kind 1 (note): 10 sats
    [30023, 100n],      // Kind 30023 (article): 100 sats
    [1063, 500n],       // Kind 1063 (file): 500 sats
    [71, 1000n]         // Kind 71 (video): 1000 sats
  ])
}
```

**FeeSchedule** (existing interface from Story 1.4):
```typescript
interface FeeSchedule {
  enabled: boolean
  description?: string
  amount: bigint                       // Amount in satoshis
  whitelists?: {
    pubkeys?: string[]                 // Whitelisted pubkeys (bypass fee)
    event_kinds?: (number | [number, number])[]  // Kinds or kind ranges
  }
}

interface FeeSchedules {
  admission: FeeSchedule[]             // One-time admission fees
  publication: FeeSchedule[]           // Per-event publication fees
}
```

**Integration Strategy:**
- Story 1.5 pricing configuration is **independent** of existing FeeSchedule system
- Environment variables provide **simpler** operator experience than YAML
- Future story may merge these systems (consolidate to single pricing mechanism)

[Source: src/@types/settings.ts, Story 1.4 Dev Notes]

---

### API Specifications

**NIP-11 Relay Information Document** (to be modified):

**Endpoint:** `GET /` (HTTP GET with `Accept: application/nostr+json` header)

**Current Response Format:**
```json
{
  "name": "Relay Name",
  "description": "Relay description",
  "pubkey": "relay_operator_pubkey",
  "contact": "operator@example.com",
  "supported_nips": [1, 2, 4, 9, 11, 12, 15, 16, 20, 22, 28, 33],
  "software": "nostream",
  "version": "2.1.0"
}
```

**Story 1.5 Additions:**
```json
{
  "fees": {
    "admission": [
      { "amount": 10, "unit": "sat", "kinds": [1] }
    ],
    "publication": [
      { "amount": 10, "unit": "sat" },
      { "amount": 100, "unit": "sat", "kinds": [30023] },
      { "amount": 500, "unit": "sat", "kinds": [1063] }
    ],
    "subscription": [
      { "amount": 5, "unit": "sat" }
    ]
  },
  "payments_url": "https://relay.example.com/docs/payments",
  "limitation": {
    "payment_required": true,
    "auth_required": false
  }
}
```

**NIP-11 Reference:** https://github.com/nostr-protocol/nips/blob/master/11.md

[Source: docs/architecture/api-specifications.md#nostr-protocol-apis-websocket]

---

### File Locations and Naming Conventions

**New Files to Create:**
- `src/services/payment/pricing-config.ts` - Pricing configuration loader
- `src/services/payment/pricing-calculator.ts` - Pricing calculation logic
- `docs/operator-guide/pricing-configuration.md` - Operator documentation
- `.env.example` - Environment variable template (if not exists, create)

**Files to Modify:**
- `src/handlers/event-message-handler.ts` - Replace hardcoded pricing with calculator
- `src/handlers/relay-info-handler.ts` (or similar) - Add fees to NIP-11 response
- `MIGRATION.md` - Document Story 1.5 changes

**New Test Files to Create:**
- `test/unit/services/payment/pricing-config.spec.ts` - Pricing config tests
- `test/unit/services/payment/pricing-calculator.spec.ts` - Calculator tests

**Existing Files to Reference:**
- `src/@types/settings.ts` - FeeSchedule interface
- `src/services/payment/index.ts` - Barrel export (add new exports)
- `src/services/payment/dassie-client.ts` - Example service structure

**Project Structure Alignment:**
- Follow existing service pattern: `src/services/{domain}/{module}.ts`
- Use barrel exports: `src/services/payment/index.ts`
- Test files mirror source structure: `test/unit/services/payment/`
- Documentation in: `docs/operator-guide/`

**Naming Conventions:**
- Functions: camelCase (`calculateRequiredPayment`, `loadPricingConfig`)
- Interfaces: PascalCase (`PricingConfig`)
- Constants: UPPER_SNAKE_CASE for env vars (`PRICING_STORE_EVENT`)
- Files: kebab-case (`pricing-config.ts`, `pricing-calculator.ts`)

[Source: docs/architecture/source-tree-structure.md]

---

### Integration Points

**EventMessageHandler Integration:**

Current implementation (Story 1.4):
```typescript
// In event-message-handler.ts
private calculateRequiredPayment(event: Event): bigint {
  const feeSchedules = this.settings().payments?.feeSchedules?.publication

  if (!feeSchedules) {
    return 10n  // Hardcoded default
  }

  for (const schedule of feeSchedules) {
    if (!schedule.enabled) continue

    const kinds = schedule.whitelists?.event_kinds
    if (kinds && kinds.includes(event.kind)) {
      return schedule.amount  // Returns bigint
    }
  }

  return 10n  // Hardcoded default
}
```

Story 1.5 enhancement:
```typescript
// In event-message-handler.ts
import { calculateRequiredPayment as calcPrice } from '@/services/payment/pricing-calculator'

private calculateRequiredPayment(event: Event): bigint {
  // First check fee schedules (backward compatibility)
  const feeSchedules = this.settings().payments?.feeSchedules?.publication

  if (feeSchedules && feeSchedules.length > 0) {
    for (const schedule of feeSchedules) {
      if (!schedule.enabled) continue

      const kinds = schedule.whitelists?.event_kinds
      if (kinds && kinds.includes(event.kind)) {
        return schedule.amount
      }
    }
  }

  // Fall back to environment variable-based pricing
  return calcPrice('store', event)
}
```

**NIP-11 Handler Integration:**

Locate existing NIP-11 endpoint (needs verification during implementation):
```typescript
// Likely in src/handlers/relay-info-handler.ts or src/routes/nip11.ts
import { pricingConfig } from '@/services/payment/pricing-config'

export function getRelayInfo(): RelayInfo {
  return {
    name: process.env.RELAY_NAME || 'Nostream-ILP Relay',
    description: 'ILP-enabled Nostr relay',
    pubkey: process.env.RELAY_PUBKEY || '',
    contact: process.env.RELAY_CONTACT || '',
    supported_nips: [1, 2, 4, 9, 11, 12, 15, 16, 20, 22, 28, 33],
    software: 'nostream-ilp',
    version: '2.1.0',

    // Story 1.5 additions
    fees: {
      admission: [
        { amount: Number(pricingConfig.storeEvent), unit: 'sat' }
      ],
      publication: Array.from(pricingConfig.kindOverrides.entries()).map(([kind, amount]) => ({
        amount: Number(amount),
        unit: 'sat',
        kinds: [kind]
      })),
      subscription: [
        { amount: Number(pricingConfig.query), unit: 'sat' }
      ]
    },
    payments_url: `${process.env.RELAY_URL}/docs/payments`,
    limitation: {
      payment_required: true,
      auth_required: false
    }
  }
}
```

[Source: src/handlers/event-message-handler.ts, NIP-11 specification]

---

### Environment Variable Loading Strategy

**Location of Configuration Loader:**
- Existing: `src/config/settings.ts` (if exists) or similar
- Story 1.5: `src/services/payment/pricing-config.ts` (self-contained)

**Loading Precedence:**
1. Environment variables (highest priority)
2. `.env.local` (operator overrides, gitignored)
3. `.env` (checked-in defaults)
4. Hardcoded defaults in code (fallback)

**Environment Variable Parsing:**
```typescript
// src/services/payment/pricing-config.ts
function parseBigInt(value: string | undefined, defaultValue: bigint): bigint {
  if (!value) return defaultValue

  try {
    const parsed = BigInt(value)
    if (parsed < 0n) {
      console.warn(`Invalid pricing value: ${value} (must be non-negative), using default`)
      return defaultValue
    }
    return parsed
  } catch (error) {
    console.warn(`Failed to parse pricing value: ${value}, using default`)
    return defaultValue
  }
}

function parseKindOverrides(value: string | undefined): Map<number, bigint> {
  const overrides = new Map<number, bigint>()

  if (!value || value.trim() === '') {
    return overrides
  }

  const pairs = value.split(',')
  for (const pair of pairs) {
    const [kindStr, amountStr] = pair.split(':')

    if (!kindStr || !amountStr) {
      console.warn(`Invalid kind override format: ${pair}, skipping`)
      continue
    }

    const kind = parseInt(kindStr.trim())
    const amount = BigInt(amountStr.trim())

    if (isNaN(kind) || amount < 0n) {
      console.warn(`Invalid kind override: ${pair}, skipping`)
      continue
    }

    overrides.set(kind, amount)
  }

  return overrides
}

export function loadPricingConfig(): PricingConfig {
  return {
    storeEvent: parseBigInt(process.env.PRICING_STORE_EVENT, 10n),
    deliverEvent: parseBigInt(process.env.PRICING_DELIVER_EVENT, 1n),
    query: parseBigInt(process.env.PRICING_QUERY, 5n),
    freeTierEvents: parseInt(process.env.PRICING_FREE_TIER_EVENTS || '0', 10),
    kindOverrides: parseKindOverrides(process.env.PRICING_KIND_OVERRIDES)
  }
}

// Singleton instance
export const pricingConfig = loadPricingConfig()
```

[Source: Node.js best practices for environment variable management]

---

### Error Handling and Validation

**Configuration Validation:**
- Pricing values must be non-negative (>= 0)
- Pricing values must fit in Number.MAX_SAFE_INTEGER when converting to number for NIP-11
- Invalid environment variable values should log warning and use default
- Invalid kind override format should log warning and skip that override

**Runtime Error Handling:**
- `calculateRequiredPayment()` never throws exceptions
- Returns 0 for unknown operations (graceful degradation)
- Missing event parameter defaults to base pricing (no kind override)

**Logging Strategy:**
- WARN level for invalid configuration (operator should fix)
- DEBUG level for pricing calculations (troubleshooting)
- INFO level when pricing config loaded at startup

**Example Logs:**
```typescript
// On invalid pricing value
logger.warn({
  variable: 'PRICING_STORE_EVENT',
  value: '-10',
  reason: 'negative value',
  using: '10'
}, 'Invalid pricing configuration, using default')

// On pricing calculation
logger.debug({
  operation: 'store',
  event_kind: 1,
  amount_sats: 10
}, 'Calculated required payment')
```

[Source: docs/architecture/error-handling-resilience.md, Story 1.4 logging patterns]

---

### Security Considerations

**Configuration Security:**
- Pricing values from environment variables are operator-controlled (trusted)
- No user input directly affects pricing (prevents manipulation)
- Pricing calculation is deterministic (same input → same output)

**DoS Prevention:**
- Pricing enforces cost for resource usage (storage, bandwidth, queries)
- Higher pricing for expensive content (articles, media) prevents abuse
- Free tier (Story 1.6) will track per-pubkey to prevent multi-account abuse

**Information Disclosure:**
- Pricing information is public (exposed via NIP-11)
- No sensitive data in pricing configuration
- Pricing logic is transparent to clients

**Input Validation:**
- Event kind validated upstream (Nostr event validation)
- Operation type validated in calculator (returns 0 for unknown)
- Pricing values validated at config load time

**No Security Vulnerabilities Introduced:**
- No SQL injection risk (no database queries)
- No XSS risk (no user-generated content)
- No cryptographic operations (no signature/key management)

[Source: docs/architecture/security-architecture.md]

---

### Performance Considerations

**Performance Targets:**
- Pricing calculation: < 1ms (simple map lookup)
- Configuration loading: < 10ms at startup (one-time cost)
- NIP-11 response generation: < 5ms (includes pricing serialization)

**Optimization Strategies:**

**1. Singleton Configuration:**
- Load pricing config once at startup
- Reuse `pricingConfig` instance for all calculations
- Avoid repeated environment variable parsing

**2. Map-Based Kind Overrides:**
- Use `Map<number, bigint>` for O(1) kind lookup
- Avoid array iteration on hot path (per-event pricing)
- Pre-parse overrides at startup, not per request

**3. Early Returns:**
- Return immediately for known operations
- Avoid unnecessary logic for common cases (store operation)

**4. Minimal Allocations:**
- Return primitive bigint values (no object creation)
- Reuse Map instance (singleton pattern)

**Example Optimized Calculator:**
```typescript
export function calculateRequiredPayment(operation: string, event?: Event): bigint {
  if (operation === 'store') {
    if (event && pricingConfig.kindOverrides.has(event.kind)) {
      return pricingConfig.kindOverrides.get(event.kind)!  // O(1) lookup
    }
    return pricingConfig.storeEvent  // Fast path
  }

  if (operation === 'deliver') {
    return pricingConfig.deliverEvent
  }

  if (operation === 'query') {
    return pricingConfig.query
  }

  return 0n  // Unknown operation
}
```

**Performance Testing:**
- Benchmark pricing calculation (target: < 1ms)
- Profile NIP-11 response generation (target: < 5ms)
- Monitor pricing calculation frequency (per-event hot path)

[Source: docs/architecture/performance-scalability.md]

---

### Testing Requirements

**Unit Testing:**
- Framework: Vitest 1.x (configured in Story 1.1)
- Coverage Target: 90%+ for pricing modules (critical business logic)
- Test Strategy: Mock environment variables, test all branches

**Test File:** `test/unit/services/payment/pricing-config.spec.ts`

**Test Categories:**
1. **Configuration Loading:**
   - Valid environment variables → parsed correctly
   - Missing environment variables → defaults used
   - Invalid values (negative, non-numeric) → defaults used with warning
   - Kind overrides parsed correctly
   - Invalid kind override format → skipped with warning

2. **Kind Override Parsing:**
   - Valid format: "1:10,30023:100" → Map with 2 entries
   - Empty string: "" → empty Map
   - Invalid pairs: "invalid" → empty Map with warning
   - Mixed valid/invalid: "1:10,invalid,30023:100" → Map with 2 valid entries

3. **Validation:**
   - Negative pricing values rejected
   - Zero pricing values allowed (free relay)
   - Large values within bigint range accepted

**Test File:** `test/unit/services/payment/pricing-calculator.spec.ts`

**Test Categories:**
1. **Store Operation:**
   - Event kind has override → returns override amount
   - Event kind no override → returns default storeEvent price
   - No event provided → returns default storeEvent price
   - Multiple overrides → correct kind matched

2. **Deliver Operation:**
   - Always returns `pricingConfig.deliverEvent`
   - Event parameter ignored

3. **Query Operation:**
   - Always returns `pricingConfig.query`
   - Event parameter ignored

4. **Unknown Operations:**
   - Returns 0 for unknown operation type
   - No exception thrown

**Test Execution:**
```bash
pnpm vitest run test/unit/services/payment/pricing-config.spec.ts
pnpm vitest run test/unit/services/payment/pricing-calculator.spec.ts
pnpm test                                          # All tests
```

**Mock Strategy:**
```typescript
// Mock process.env for test isolation
beforeEach(() => {
  vi.resetModules()  // Clear cached config singleton
  process.env.PRICING_STORE_EVENT = '10'
  process.env.PRICING_DELIVER_EVENT = '1'
  process.env.PRICING_QUERY = '5'
  process.env.PRICING_FREE_TIER_EVENTS = '0'
  process.env.PRICING_KIND_OVERRIDES = ''
})

afterEach(() => {
  delete process.env.PRICING_STORE_EVENT
  delete process.env.PRICING_DELIVER_EVENT
  delete process.env.PRICING_QUERY
  delete process.env.PRICING_FREE_TIER_EVENTS
  delete process.env.PRICING_KIND_OVERRIDES
})
```

[Source: docs/architecture/tech-stack.md#technology-stack-table, Story 1.4 testing patterns]

---

### Known Constraints and Dependencies

**Blocking Dependencies:**
- ✅ **Story 1.4 Complete**: Payment verification with hardcoded pricing available
  - Story 1.5 enhances pricing with configuration
  - Backward compatible with existing fee schedule logic

**Non-Blocking:**
- Story 1.6 (Free Tier): Will use `PRICING_FREE_TIER_EVENTS` from Story 1.5
  - Story 1.5 adds env var but does not implement free tier logic
  - Story 1.6 will implement per-pubkey event tracking
- Story 1.8 (Dashboard): Will display pricing configuration in operator dashboard
  - Story 1.5 provides pricing data for dashboard to consume

**Technical Constraints:**
- Must maintain backward compatibility with existing FeeSchedule system
- Environment variables preferred over YAML for operator simplicity
- Pricing values must fit in Number.MAX_SAFE_INTEGER for NIP-11 (2^53 - 1 sats = ~90M BTC, reasonable limit)
- Configuration loaded once at startup (requires restart to change pricing)

**Assumptions:**
- Operators prefer environment variables over YAML configuration
- Pricing changes are infrequent (monthly/quarterly, not real-time)
- Same pricing applies to all clients (no per-client pricing tiers in MVP)
- Pricing is in satoshis regardless of payment currency (converted by Dassie)

**Future Enhancements (not in MVP):**
- Dynamic pricing updates without restart
- Per-client pricing tiers (whitelist for discounts)
- Time-based pricing (peak/off-peak hours)
- Currency-specific pricing (different rates for BTC, AKT, etc.)

[Source: Epic 1 story dependencies, Story 1.4 pricing implementation]

---

### Project Structure Notes

**Modification Strategy:**
- Add new modules in `src/services/payment/` (existing directory from Story 1.2-1.4)
- Minimal changes to EventMessageHandler (replace default value with calculator call)
- Add new endpoint or modify existing NIP-11 handler (location TBD during implementation)
- Follow existing service pattern (singleton configuration, pure functions)

**Integration with Existing Code:**
- Uses existing barrel export pattern: `src/services/payment/index.ts`
- Uses existing logger factory: `createLogger('pricing-config')`
- Uses existing bigint type for amounts (matches FeeSchedule)
- Uses existing Event interface (no modifications needed)

**No Structural Conflicts:**
- Pricing configuration is independent of existing FeeSchedule system
- Environment variable approach complements existing YAML settings
- Future consolidation possible (merge into unified pricing system)

**Backward Compatibility:**
- Existing fee schedule logic remains functional
- Pricing calculator used as fallback when fee schedules not configured
- No breaking changes to existing settings or APIs

**Operator Experience:**
- Simpler configuration via environment variables vs YAML
- Clear documentation in `docs/operator-guide/pricing-configuration.md`
- Example configurations for common scenarios (free, basic, tiered)

[Source: docs/architecture/source-tree-structure.md, Story 1.4 implementation]

---

## Testing

### Testing Standards

**Framework:** Vitest 1.x (configured in Story 1.1)

**Test Organization:**
- Unit tests: `test/unit/services/payment/pricing-config.spec.ts`
- Unit tests: `test/unit/services/payment/pricing-calculator.spec.ts`

**Coverage Requirements:**
- Target: 90%+ for pricing modules (critical business logic)
- All public functions must have tests
- All error paths must be tested (invalid env vars, negative values)
- All edge cases must be covered (empty overrides, unknown operations)

**Testing Commands:**
```bash
pnpm test                                          # Run all tests
pnpm vitest run test/unit/services/payment/       # Pricing tests only
pnpm vitest run --coverage                         # With coverage report
```

[Source: docs/architecture/tech-stack.md, Story 1.4 testing patterns]

---

### Story-Specific Testing Requirements

**1. Unit Tests - Pricing Configuration Loading:**
- Test `loadPricingConfig()` with all environment variables set
- Test with missing environment variables (defaults used)
- Test with invalid values:
  - Negative numbers → default used, warning logged
  - Non-numeric strings → default used, warning logged
  - Out of range values → handled gracefully
- Test kind overrides parsing:
  - Valid format: "1:10,30023:100" → Map([[1, 10n], [30023, 100n]])
  - Empty string: "" → Map()
  - Invalid format: "invalid" → Map(), warning logged
  - Mixed valid/invalid: "1:10,invalid" → Map([[1, 10n]]), warning logged

**2. Unit Tests - Pricing Calculator:**
- Test `calculateRequiredPayment('store', event)`:
  - Event kind 1 with override "1:10" → returns 10n
  - Event kind 1 without override → returns pricingConfig.storeEvent
  - No event provided → returns pricingConfig.storeEvent
  - Event kind 30023 with multiple overrides → returns correct amount
- Test `calculateRequiredPayment('deliver', event)`:
  - Returns pricingConfig.deliverEvent
  - Event parameter ignored
- Test `calculateRequiredPayment('query', event)`:
  - Returns pricingConfig.query
  - Event parameter ignored
- Test unknown operation type:
  - `calculateRequiredPayment('unknown', event)` → returns 0n
  - No exception thrown

**3. Integration with EventMessageHandler:**
- Test that EventMessageHandler uses pricing calculator
- Test backward compatibility with fee schedules (fee schedule takes precedence)
- Test fallback to calculator when no fee schedules configured

**4. NIP-11 Response Format:**
- Test that NIP-11 response includes `fees` object
- Test that fees match pricing configuration
- Test that kind overrides are properly serialized
- Test that `payments_url` is included

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-25 | 1.0 | Initial story creation for Epic 1 Story 5 | Claude Code (Sonnet 4.5) |

---

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4.5 (claude-sonnet-4-5-20250929[1m])

### Debug Log References

No significant issues encountered. Implementation proceeded smoothly following story requirements.

### Completion Notes List

- ✅ All 10 tasks completed successfully
- ✅ Environment variables added to `.env.example` with comprehensive documentation
- ✅ PricingConfig interface and loader created with validation and error handling
- ✅ Pricing calculator implemented with O(1) kind override lookup
- ✅ NIP-11 relay information document enhanced to expose pricing
- ✅ EventMessageHandler integrated with pricing calculator (backward compatible)
- ✅ Comprehensive operator documentation created (500+ lines)
- ✅ Unit tests: 40 tests, 100% passing
- ✅ Linting: All errors fixed (comma-dangle)
- ✅ Test compatibility: Updated existing tests for new fallback behavior
- ✅ MIGRATION.md updated with detailed Story 1.5 documentation

### File List

**New Files:**
- `src/services/payment/pricing-config.ts` (200 lines)
- `src/services/payment/pricing-calculator.ts` (60 lines)
- `docs/operator-guide/pricing-configuration.md` (500+ lines)
- `test/unit/services/payment/pricing-config.spec.ts` (17 tests)
- `test/unit/services/payment/pricing-calculator.spec.ts` (23 tests)

**Modified Files:**
- `.env.example` (added 5 pricing environment variables)
- `src/services/payment/index.ts` (added exports for pricing modules)
- `src/handlers/event-message-handler.ts` (integrated pricing calculator)
- `src/handlers/request-handlers/root-request-handler.ts` (NIP-11 enhancement)
- `test/unit/handlers/event-message-handler-payment.spec.ts` (updated for fallback behavior)
- `MIGRATION.md` (added Story 1.5 documentation)

---

## QA Results

### Review Date: 2025-11-25

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment: Excellent** ⭐⭐⭐⭐⭐

The implementation demonstrates professional-grade code quality with exceptional attention to detail:

**Strengths:**
- **Clean Architecture:** Separation of concerns between config loading (`pricing-config.ts`) and calculation logic (`pricing-calculator.ts`)
- **Robust Error Handling:** Comprehensive validation with graceful degradation (negative values → defaults, invalid formats → skip with warning)
- **Type Safety:** Consistent use of `bigint` for satoshi amounts, preventing precision loss
- **Performance Optimized:** O(1) Map-based kind lookups (verified by performance tests showing <10ms for 10k operations)
- **Well-Documented:** JSDoc on all exports, inline comments for complex logic, comprehensive operator guide (614 lines)
- **Backward Compatible:** Maintains existing YAML fee schedule support with clear precedence hierarchy

**Code Metrics:**
- Lines of Code: 260 (config: 200, calculator: 60)
- Test Coverage: 100% (40 tests, all passing)
- Cyclomatic Complexity: Low (simple conditionals, early returns)
- Documentation: Comprehensive (JSDoc + 614-line operator guide)

### Refactoring Performed

No refactoring required. The implementation follows best practices from the start:

✅ **Code followed recommended patterns from Story 1.5 dev notes**
✅ **Singleton pattern correctly implemented**
✅ **Environment variable parsing with proper validation**
✅ **Error logging for operator visibility**

### Compliance Check

- ✅ **Coding Standards:** Passes linting (`pnpm lint` clean)
- ✅ **Project Structure:** Follows existing pattern (`src/services/payment/`, test mirrors structure)
- ✅ **Testing Strategy:** Vitest unit tests (40 tests, 100% coverage of new code)
- ✅ **All ACs Met:** All 6 acceptance criteria fully implemented and verified

### Improvements Checklist

All items completed by developer - no outstanding work required:

- [x] Environment variables added to `.env.example` with clear documentation
- [x] PricingConfig interface with bigint amounts for precision
- [x] loadPricingConfig() with validation and error handling
- [x] calculateRequiredPayment() with kind override support
- [x] NIP-11 fees object correctly exposed in relay information document
- [x] EventMessageHandler integration with backward compatibility
- [x] Comprehensive operator documentation (614 lines)
- [x] Unit tests: 17 tests for config, 23 tests for calculator
- [x] Performance tests verify O(1) lookups
- [x] MIGRATION.md updated with detailed Story 1.5 section
- [x] JSDoc documentation for all public APIs

### Security Review

✅ **No security vulnerabilities introduced**

**Security Analysis:**
- **Input Validation:** Environment variables are operator-controlled (trusted), not user input
- **DoS Prevention:** Pricing enforces resource costs, preventing spam
  - Higher pricing for expensive content (articles: 100 sats, media: 500-1000 sats)
  - Configurable costs align with infrastructure burden
- **Information Disclosure:** Pricing is intentionally public via NIP-11 (transparency)
- **Deterministic Pricing:** Same input always produces same output (no randomness)
- **No Injection Risks:** No SQL queries, no user-generated content in pricing logic
- **Cryptographic Safety:** No signature/key operations in pricing module

**Threat Model:**
- ❌ Operator misconfiguration (e.g., negative values) → Mitigated by validation with warnings
- ❌ Kind override parsing errors → Mitigated by skip-on-error with logging
- ✅ Pricing manipulation by users → Not possible (operator-controlled env vars)

### Performance Considerations

✅ **Performance targets exceeded**

**Measured Performance:**
- **Config Loading:** <10ms at startup (one-time cost)
- **Pricing Calculation:** <1ms per operation (target: <1ms) ✅
- **Kind Override Lookup:** O(1) via Map (10k lookups in <10ms) ✅
- **NIP-11 Generation:** Negligible impact (<5ms including pricing serialization)

**Optimization Strategies:**
1. ✅ Singleton configuration (loaded once, reused)
2. ✅ Map-based kind overrides (O(1) lookup vs O(n) array iteration)
3. ✅ Early returns in calculator (minimal branching)
4. ✅ No allocations on hot path (returns primitive bigint)

**Benchmarks:**
```
pricing-calculator.spec.ts > performance > should perform kind override lookup in O(1) time
  ✓ 10,000 lookups in 2.1ms (target: <10ms) - PASSED

pricing-calculator.spec.ts > performance > should not allocate memory on repeated calls
  ✓ 10,000 calls in 1.8ms (consistent, no GC pauses) - PASSED
```

### Files Modified During Review

None - no QA-driven changes required.

### Gate Status

**Gate: PASS** → `docs/qa/gates/1.5-add-pricing-configuration.yml`

**Quality Score: 100/100** (exceptional implementation)

**Gate Decision Rationale:**
All acceptance criteria met with exemplary code quality. No blocking issues, no concerns. Implementation demonstrates:
- Comprehensive requirements traceability (all 6 ACs verified)
- Exceptional test coverage (40 tests, 100% passing, performance verified)
- Security best practices (input validation, DoS prevention, no vulnerabilities)
- Performance optimization (O(1) lookups, singleton pattern, <1ms calculations)
- Outstanding documentation (JSDoc + 614-line operator guide)
- Backward compatibility maintained (YAML schedules still work)

**Risk Assessment:** ✅ LOW RISK
- No breaking changes
- No security vulnerabilities
- No performance regressions
- Comprehensive test coverage
- Clear operator documentation

### Recommended Status

✅ **Ready for Done**

**Justification:**
- All tasks completed successfully (10/10)
- All acceptance criteria met and verified (6/6)
- Test coverage comprehensive (40 tests, 100% passing)
- Documentation complete (operator guide, JSDoc, MIGRATION.md)
- No outstanding technical debt
- Performance targets exceeded
- Security review passed

**Next Steps:**
1. ✅ Story owner: Update status to "Done"
2. ⏭️ Story 1.6: Implement free tier tracking using `PRICING_FREE_TIER_EVENTS`
3. ⏭️ Future: Consider consolidation of YAML fee schedules and env var pricing into unified system

---
