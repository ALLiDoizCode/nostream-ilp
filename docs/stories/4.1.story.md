# Story 4.1: Create Multi-Token Payment Channel Factory Contract

## Status

Draft

## Story

**As a** developer,
**I want** a payment channel factory that supports any ERC-20 token,
**so that** users can open channels with AKT, CRO, USDC, or any token on Cronos/Base.

## Acceptance Criteria

1. New contract created: `contracts/MultiTokenPaymentChannelFactory.sol`
2. Contract supports dynamic token selection per channel:
   ```solidity
   function openChannel(
       address tokenAddress,  // Any ERC-20 token
       address recipient,
       uint256 amount,
       uint256 expiration
   ) external returns (bytes32 channelId)
   ```
3. Channel struct includes token address:
   ```solidity
   struct Channel {
       address sender;
       address recipient;
       address token;         // ← NEW: Dynamic per channel
       uint256 balance;
       uint256 highestNonce;
       uint256 expiration;
       bool isClosed;
   }
   ```
4. `closeChannel()` and `expireChannel()` handle token-specific transfers:
   - Use `IERC20(channel.token).transfer()` instead of hardcoded token
5. Support for native ETH channels (special case: `address(0)` = ETH)
6. Comprehensive test suite:
   - Test with multiple ERC-20 tokens (MockAKT, MockUSDC, MockCRO)
   - Test with native ETH
   - Test multiple simultaneous channels with different tokens
   - Test that channels are isolated (AKT channel can't claim USDC)
7. Gas optimization: Similar costs to single-token contract
8. Security: Validate token address is contract (prevent EOA addresses)
9. Events include token address for indexing:
   ```solidity
   event ChannelOpened(
       bytes32 indexed channelId,
       address indexed sender,
       address indexed recipient,
       address token,      // ← NEW
       uint256 balance,
       uint256 expiration
   )
   ```
10. Top-up functionality for channel senders:
   ```solidity
   function topUpChannel(
       bytes32 channelId,
       uint256 amount
   ) external
   ```
11. Top-up validation:
   - Only sender can top-up their own channel
   - Channel must not be closed
   - Transfer tokens to contract
   - Increase channel balance
   - Emit ChannelToppedUp event
12. Top-up events:
   ```solidity
   event ChannelToppedUp(
       bytes32 indexed channelId,
       address indexed sender,
       uint256 amount,
       uint256 newBalance,
       uint256 timestamp
   )
   ```
13. Test top-up scenarios:
   - Test sender can top-up their channel
   - Test top-up with different token types (USDC, ETH)
   - Test multiple top-ups on same channel
   - Test top-up after channel has been used (nonce > 0)
   - Test rejection: recipient cannot top-up
   - Test rejection: cannot top-up closed channel

## Tasks / Subtasks

- [ ] Task 1: Design Multi-Token Factory Architecture (AC: 1, 2, 3)
  - [ ] Review CronosPaymentChannel.sol from Story 3.1 as baseline
  - [ ] Identify modifications needed for multi-token support
  - [ ] Add `address token` parameter to openChannel()
  - [ ] Add `address token` field to Channel struct
  - [ ] Document design decisions in contracts/README.md
  - [ ] Reference: docs/prd/epic-4-economic-monitoring-self-sustainability.md

- [ ] Task 2: Create MultiTokenPaymentChannelFactory Contract (AC: 1, 2, 3, 4)
  - [ ] Create file: `contracts/MultiTokenPaymentChannelFactory.sol`
  - [ ] Copy structure from CronosPaymentChannel.sol
  - [ ] Remove hardcoded `aktToken` immutable variable
  - [ ] Add `address token` parameter to `openChannel()` function signature
  - [ ] Update Channel struct to include `address token` field
  - [ ] Modify `openChannel()` to use dynamic token:
    ```solidity
    IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);
    channels[channelId].token = tokenAddress;
    ```
  - [ ] Modify `closeChannel()` to use `channel.token`:
    ```solidity
    IERC20(channel.token).transfer(channel.recipient, claimAmount);
    IERC20(channel.token).transfer(channel.sender, refundAmount);
    ```
  - [ ] Modify `expireChannel()` to use `channel.token`:
    ```solidity
    IERC20(channel.token).transfer(channel.sender, channel.balance);
    ```
  - [ ] Update ChannelOpened event to include token address parameter
  - [ ] Add NatSpec documentation for multi-token support

- [ ] Task 3: Add Native ETH Support (AC: 5)
  - [ ] Add special handling for `address(0)` representing native ETH
  - [ ] Update `openChannel()` to handle ETH:
    ```solidity
    if (tokenAddress == address(0)) {
        require(msg.value == amount, "ETH amount mismatch");
    } else {
        require(msg.value == 0, "ETH not expected for ERC-20");
        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);
    }
    ```
  - [ ] Update `closeChannel()` to handle ETH transfers:
    ```solidity
    if (channel.token == address(0)) {
        payable(channel.recipient).transfer(claimAmount);
        if (refundAmount > 0) payable(channel.sender).transfer(refundAmount);
    } else {
        // ERC-20 transfers
    }
    ```
  - [ ] Update `expireChannel()` similarly
  - [ ] Add `payable` modifier to openChannel() for ETH support
  - [ ] Document ETH special case in NatSpec

- [ ] Task 4: Add Token Validation (AC: 8)
  - [ ] Add token address validation in `openChannel()`:
    ```solidity
    if (tokenAddress != address(0)) {
        // Verify token address is a contract (not EOA)
        require(tokenAddress.code.length > 0, "Invalid token address");
    }
    ```
  - [ ] Add validation that token contract implements ERC-20 interface (optional: via ERC165 or call check)
  - [ ] Document token validation requirements
  - [ ] Add error: `error InvalidTokenAddress();`

- [ ] Task 5: Compile and Verify Contract (AC: 1)
  - [ ] Run Solidity compilation: `npx hardhat compile`
  - [ ] Fix any compilation errors
  - [ ] Verify contract compiles without warnings
  - [ ] Check generated artifacts in `artifacts/contracts/MultiTokenPaymentChannelFactory.sol/`
  - [ ] Verify ABI includes new token parameter

- [ ] Task 6: Create Mock ERC-20 Tokens for Testing (AC: 6)
  - [ ] Create `contracts/test/MockUSDC.sol` (6 decimals, name "Mock USD Coin")
  - [ ] Create `contracts/test/MockCRO.sol` (18 decimals, name "Mock Cronos")
  - [ ] Both contracts extend OpenZeppelin ERC20 with public mint() function
  - [ ] Compile all mock contracts: `npx hardhat compile`
  - [ ] Verify artifacts generated correctly

- [ ] Task 7: Add Top-Up Functionality (AC: 10, 11, 12)
  - [ ] Add `topUpChannel()` function to MultiTokenPaymentChannelFactory.sol
  - [ ] Validate only sender can top-up (require msg.sender == channel.sender)
  - [ ] Validate channel is not closed (require !channel.isClosed)
  - [ ] Handle ETH top-ups (if token == address(0), use msg.value)
  - [ ] Handle ERC-20 top-ups (transferFrom msg.sender)
  - [ ] Update channel.balance += amount
  - [ ] Emit ChannelToppedUp event with all parameters
  - [ ] Add NatSpec documentation for top-up function
  - [ ] Add error: `error ChannelClosed();`
  - [ ] Add error: `error OnlySenderCanTopUp();`

- [ ] Task 8: Write Test Suite for Multi-Token Factory (AC: 6, 7, 9, 13)
  - [ ] Create file: `test/MultiTokenPaymentChannelFactory.test.ts`
  - [ ] Set up test environment:
    - [ ] Deploy MockAKT, MockUSDC, MockCRO tokens in beforeEach
    - [ ] Deploy MultiTokenPaymentChannelFactory contract
    - [ ] Mint test tokens to alice and bob
  - [ ] Test Suite: openChannel with Multiple Tokens
    - [ ] Test: "should open channel with AKT token"
    - [ ] Test: "should open channel with USDC token"
    - [ ] Test: "should open channel with CRO token"
    - [ ] Test: "should open channel with native ETH"
    - [ ] Test: "should emit ChannelOpened event with correct token address"
    - [ ] Test: "should revert if token address is EOA (not contract)"
    - [ ] Test: "should revert if ETH sent with ERC-20 token"
    - [ ] Test: "should revert if insufficient ETH sent for native channel"
  - [ ] Test Suite: closeChannel with Multiple Tokens
    - [ ] Test: "should close AKT channel and transfer AKT correctly"
    - [ ] Test: "should close USDC channel and transfer USDC correctly"
    - [ ] Test: "should close ETH channel and transfer ETH correctly"
    - [ ] Test: "should not mix tokens between channels (AKT channel can't claim USDC)"
  - [ ] Test Suite: Channel Isolation
    - [ ] Test: "should handle multiple channels with different tokens simultaneously"
      - [ ] Open channel 1: alice → bob with 100 AKT
      - [ ] Open channel 2: alice → bob with 50 USDC
      - [ ] Open channel 3: alice → bob with 1 ETH
      - [ ] Close all channels independently
      - [ ] Verify correct token balances for each
  - [ ] Test Suite: Gas Optimization Validation (AC: 7)
    - [ ] Measure gas for openChannel() with multi-token factory
    - [ ] Compare gas cost to CronosPaymentChannel (single-token)
    - [ ] Verify overhead is <10% (additional storage slot for token address)
    - [ ] Document gas costs in test output

- [ ] Task 9: Write Top-Up Test Suite (AC: 13)
  - [ ] Test Suite: topUpChannel Tests
    - [ ] Test: "should allow sender to top-up USDC channel"
    - [ ] Test: "should allow sender to top-up ETH channel with msg.value"
    - [ ] Test: "should allow multiple top-ups on same channel"
    - [ ] Test: "should increase channel balance correctly after top-up"
    - [ ] Test: "should emit ChannelToppedUp event with correct parameters"
    - [ ] Test: "should allow top-up after channel has been partially used (nonce > 0)"
    - [ ] Test: "should revert if recipient tries to top-up (not sender)"
    - [ ] Test: "should revert if trying to top-up closed channel"
    - [ ] Test: "should revert if ETH amount doesn't match msg.value"
    - [ ] Test: "should revert if sending ETH with ERC-20 top-up"
  - [ ] Integration test: Open channel, use partially, top-up, use more, close

- [ ] Task 10: Run Full Test Suite and Coverage (AC: 6, 13)
  - [ ] Run all tests: `npx hardhat test`
  - [ ] Verify all tests pass (0 failures)
  - [ ] Run coverage: `npx hardhat coverage`
  - [ ] Verify coverage >90% for MultiTokenPaymentChannelFactory.sol
  - [ ] Document test results

- [ ] Task 11: Update Contract Documentation (AC: 1, 5, 8, 9, 10, 11, 12)
  - [ ] Update `contracts/README.md` with multi-token factory section
  - [ ] Document token address parameter and special case for address(0) = ETH
  - [ ] Document token validation requirements (must be contract, not EOA)
  - [ ] Document event changes (token address added to ChannelOpened)
  - [ ] Document top-up functionality and use cases
  - [ ] Add usage examples for different token types
  - [ ] Add usage examples for top-up scenarios
  - [ ] Document gas cost comparison vs single-token contract

## Dev Notes

### Previous Story Context

**Architecture Context:**
This story builds payment channels for a **peer-to-peer BTP-NIPs network** where every participant runs their own Dassie ILP node + Nostr storage. Payment channels are **unidirectional** (only sender deposits) and support **top-up functionality** to add funds without closing/reopening.

**Story 3.6 Completion:**
Story 3.6 successfully deployed CronosPaymentChannel to Cronos mainnet at address `0x9Ec2d217b14e67cAbF86F20F4E7462D6d7bc7684`. The contract handles ERC-20 AKT tokens exclusively. All tests passed with 100% coverage.

**Epic 3 Summary (Stories 3.1-3.6):**
- Story 3.1: Created CronosPaymentChannel.sol for ERC-20 AKT support (95% code reuse from BasePaymentChannel)
- Story 3.2: Created MockAKT token and comprehensive test suite (29 tests, 100% coverage)
- Story 3.3: Configured Hardhat for Cronos networks (mainnet and testnet)
- Story 3.4: Deployed to Cronos testnet and verified contract
- Story 3.5: Created Dassie Cronos settlement module
- Story 3.6: Deployed to Cronos mainnet (production)

**Key Insights from Story 3.1 and 3.2:**
- **Contract Structure:** CronosPaymentChannel uses immutable `IERC20 public immutable aktToken` set in constructor
- **ERC-20 Transfers:** All transfers use `require(token.transfer(...), "Transfer failed")` to check return values
- **Testing Pattern:** MockAKT token with 6 decimals, public mint() function for test setup
- **Coverage Target:** >90% for all metrics (statement, branch, function, line)
- **Gas Costs:** ERC-20 transfers add ~35k gas overhead vs native ETH, but Cronos gas prices are low

[Source: docs/stories/3.1.story.md, docs/stories/3.2.story.md, docs/stories/3.6.story.md]

---

### Architecture Context

**Tech Stack for This Story:**

**Smart Contract Development:**
- **Solidity:** ^0.8.20 (locked version from Story 3.1)
- **Hardhat:** 2.x (CommonJS compatibility)
- **OpenZeppelin:** 5.4.0 (ERC20, IERC20, ReentrancyGuard, ECDSA)
- **Testing:** Hardhat with Mocha/Chai 4.5.0
- **Coverage:** solidity-coverage plugin

**Contract Standards:**
- ERC-20 interface for token integration
- Support for tokens with varying decimals (6 for AKT/USDC, 18 for CRO/ETH)
- Native ETH support via `address(0)` convention

[Source: docs/architecture/tech-stack.md]

---

### Contract Specifications

**Multi-Token Payment Channel Factory Architecture:**

**Key Differences from CronosPaymentChannel:**
1. **No Immutable Token:** Remove `IERC20 public immutable aktToken;`
2. **Dynamic Token Per Channel:** Add `address token` to Channel struct
3. **Token Parameter:** Add `address tokenAddress` to `openChannel()` function
4. **Token-Specific Transfers:** Use `IERC20(channel.token).transfer()` instead of `aktToken.transfer()`
5. **Native ETH Support:** Special handling when `tokenAddress == address(0)`

**Channel Struct (Updated):**
```solidity
struct Channel {
    address sender;        // Payer's address
    address recipient;     // Payee's address
    address token;         // ← NEW: ERC-20 token address or address(0) for ETH
    uint256 balance;       // Locked token amount
    uint256 highestNonce;  // Last verified nonce
    uint256 expiration;    // Unix timestamp for expiration
    bool isClosed;         // Channel closed flag
}
```

**Function Signatures (Updated):**
```solidity
function openChannel(
    address tokenAddress,  // ← NEW: Token address (address(0) for ETH)
    address recipient,
    uint256 amount,
    uint256 expiration
) external payable returns (bytes32 channelId)

function closeChannel(
    bytes32 channelId,
    uint256 claimAmount,
    uint256 nonce,
    bytes memory signature
) external nonReentrant

function expireChannel(bytes32 channelId) external

function getChannel(bytes32 channelId) external view returns (Channel memory)
```

**Events (Updated):**
```solidity
event ChannelOpened(
    bytes32 indexed channelId,
    address indexed sender,
    address indexed recipient,
    address token,          // ← NEW: Token address
    uint256 balance,
    uint256 expiration
);
```

[Source: docs/prd/epic-4-economic-monitoring-self-sustainability.md#story-41]

---

### File Locations and Naming Conventions

**New Files Created in This Story:**
```
contracts/
├── MultiTokenPaymentChannelFactory.sol  # NEW: Multi-token factory contract
└── test/
    ├── MockUSDC.sol                     # NEW: USDC mock (6 decimals)
    └── MockCRO.sol                      # NEW: CRO mock (18 decimals)

test/
└── MultiTokenPaymentChannelFactory.test.ts  # NEW: Test suite
```

**Existing Files Referenced:**
```
contracts/
├── CronosPaymentChannel.sol             # Reference: Single-token implementation (Story 3.1)
├── BasePaymentChannel.sol               # Reference: Native ETH implementation (Story 3.1)
└── test/
    └── MockAKT.sol                      # Existing: AKT mock from Story 3.2
```

[Source: docs/architecture/source-tree-structure.md]

---

### Data Models and Test Fixtures

**Token Specifications for Testing:**

| Token | Symbol | Decimals | Initial Supply | Purpose |
|-------|--------|----------|----------------|---------|
| MockAKT | AKT | 6 | 1,000,000 | Test AKT channels (existing from Story 3.2) |
| MockUSDC | USDC | 6 | 1,000,000 | Test stablecoin channels |
| MockCRO | CRO | 18 | 1,000,000 | Test 18-decimal token channels |
| Native ETH | ETH | 18 | N/A | Test native currency channels |

**Test Amounts:**
- AKT/USDC (6 decimals): `ethers.parseUnits("100", 6)` = 100,000,000 base units
- CRO/ETH (18 decimals): `ethers.parseUnits("1.0", 18)` = 1,000,000,000,000,000,000 wei

**Channel Test Scenarios:**
1. **Single Token Channel:** Open/close channel with one token type
2. **Multiple Token Channels:** Open multiple channels with different tokens simultaneously
3. **Channel Isolation:** Verify AKT channel cannot claim USDC funds
4. **Native ETH Channels:** Test ETH deposit/refund via `msg.value`

[Source: docs/architecture/data-models.md, docs/stories/3.2.story.md#data-models-and-test-fixtures]

---

### Security Considerations

**Multi-Token Security Risks:**

1. **Token Address Validation (AC: 8):**
   - **Risk:** Passing EOA (externally owned account) as token address could cause silent failures
   - **Mitigation:** Check `tokenAddress.code.length > 0` to ensure it's a contract
   - **Exception:** `address(0)` for native ETH is allowed

2. **Token Isolation:**
   - **Risk:** User could attempt to close AKT channel with USDC claim
   - **Protection:** `channel.token` stored in struct, transfers use specific token for that channel
   - **Test:** Verify channels with different tokens cannot interfere

3. **Native ETH vs ERC-20 Confusion:**
   - **Risk:** User sends ETH for ERC-20 channel or vice versa
   - **Mitigation:** Validate `msg.value == 0` for ERC-20 channels, `msg.value == amount` for ETH channels
   - **Test:** Revert if ETH sent with ERC-20 token or incorrect ETH amount

4. **ERC-20 Transfer Return Values:**
   - **Protection:** All `transfer()` and `transferFrom()` calls wrapped in `require()` (from Story 3.1 QA)
   - **Applies To:** All token types except native ETH

5. **Reentrancy Protection:**
   - **Protection:** OpenZeppelin ReentrancyGuard on `closeChannel()` (inherited from BasePaymentChannel)
   - **Risk Assessment:** Higher with multiple tokens (some ERC-20s may have callbacks)
   - **Test:** Integration test with malicious token (deferred to Story 4.3)

[Source: docs/architecture/security-architecture.md, docs/stories/3.1.story.md#security-considerations]

---

### Gas Cost Analysis

**Expected Gas Overhead for Multi-Token Factory:**

**Additional Storage:**
- `address token` in Channel struct: +1 storage slot per channel

**Gas Impact:**
- **openChannel():** +20,000 gas for extra SSTORE (token address)
- **closeChannel():** Negligible (reads existing storage)
- **expireChannel():** Negligible (reads existing storage)

**Comparison to CronosPaymentChannel (Single Token):**
| Function | Single-Token | Multi-Token | Overhead |
|----------|--------------|-------------|----------|
| openChannel | ~70,000 gas | ~90,000 gas | +28% |
| closeChannel | ~95,000 gas | ~95,000 gas | 0% |
| expireChannel | ~65,000 gas | ~65,000 gas | 0% |

**AC: 7 Validation:** Gas overhead <10% overall
- Overhead is concentrated in `openChannel()` (one-time cost)
- `closeChannel()` and `expireChannel()` have no additional cost
- **Weighted Average:** ~10-15% overhead (acceptable for multi-token flexibility)

**Optimization Opportunities:**
- Pack `token` address with other Channel fields if possible
- Consider using smaller data types where appropriate
- Defer gas optimization to Story 4.2 if needed

[Source: docs/research/cronos-akt-deployment/findings/gas-cost-comparison.md, Story 3.2 gas measurements]

---

### Known Constraints and Dependencies

**Blockers:**
- Story 3.6 MUST be complete (status: Done) - Cronos mainnet deployment verified

**Prerequisites:**
- Hardhat 2.x configured (from Story 3.1)
- CronosPaymentChannel.sol exists as reference (from Story 3.1)
- MockAKT.sol exists from Story 3.2

**Outputs for Future Stories:**
- Story 4.2 (Multi-Chain Deployment): Will deploy this factory to Cronos, Base, and Arbitrum mainnets
- Story 4.3 (Dassie Multi-Token Support): Will integrate with this factory for dynamic token handling

**Assumptions:**
- All ERC-20 tokens follow standard interface (transfer, transferFrom, balanceOf)
- Native ETH `address(0)` convention is acceptable
- Gas overhead from multi-token support is acceptable for flexibility gained

**Deferred to Future Stories:**
- Multi-chain deployment (Story 4.2)
- Token whitelist configuration (Story 4.2)
- Dassie integration (Story 4.3)
- Production gas optimization (Story 4.2 or later)

[Source: docs/prd/epic-4-economic-monitoring-self-sustainability.md]

---

## Testing

### Testing Standards

**Framework:** Hardhat with Mocha/Chai 4.5.0 (from Story 3.2)

**Test Locations:**
- Test file: `test/MultiTokenPaymentChannelFactory.test.ts`
- Mock contracts: `contracts/test/MockUSDC.sol`, `contracts/test/MockCRO.sol`

**Test Approach:**
- Unit tests with multiple mock ERC-20 tokens
- Native ETH integration tests
- Channel isolation tests (verify token separation)
- Gas profiling (compare to single-token contract)

[Source: docs/architecture/tech-stack.md#testing]

---

### Story-Specific Testing Requirements

**Test Coverage Target:** >90% (AC: 6)

**Test Suites:**

1. **Deployment Tests:**
   - Verify factory deploys successfully
   - Verify no constructor dependencies (unlike CronosPaymentChannel with aktToken)

2. **Multi-Token openChannel Tests:**
   - Test with AKT (6 decimals)
   - Test with USDC (6 decimals)
   - Test with CRO (18 decimals)
   - Test with native ETH (address(0))
   - Verify ChannelOpened event includes correct token address
   - Verify token validation (revert on EOA address)

3. **closeChannel Tests:**
   - Close AKT channel → verify AKT transfers
   - Close USDC channel → verify USDC transfers
   - Close CRO channel → verify CRO transfers
   - Close ETH channel → verify ETH transfers
   - Verify signature verification still works (unchanged from Story 3.1)

4. **Channel Isolation Tests:**
   - Open 3 channels with different tokens simultaneously
   - Close each channel independently
   - Verify correct token balances for all parties
   - Verify no cross-token contamination

5. **Native ETH Tests:**
   - Test openChannel with `address(0)` and `msg.value`
   - Test closeChannel refunds ETH correctly
   - Test expireChannel refunds ETH correctly
   - Verify ETH cannot be sent with ERC-20 channels

6. **Gas Profiling Tests:**
   - Measure gas for openChannel (multi-token vs single-token)
   - Measure gas for closeChannel (should be similar)
   - Verify overhead is acceptable (<10% weighted average)
   - Document gas costs in test output

**Test Commands:**
```bash
npx hardhat test                                           # Run all tests
npx hardhat test test/MultiTokenPaymentChannelFactory.test.ts  # Run specific test
REPORT_GAS=true npx hardhat test                           # With gas reporting
npx hardhat coverage                                       # Coverage report
```

[Source: docs/stories/3.2.story.md#testing-strategy-and-coverage-requirements]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-30 | 1.0 | Initial story creation for Epic 4 Story 1 | Claude Code (Sonnet 4.5) |

---

## Dev Agent Record

### Agent Model Used

_To be populated by Dev Agent_

### Debug Log References

_To be populated by Dev Agent during implementation_

### Completion Notes List

_To be populated by Dev Agent after story completion_

### File List

_To be populated by Dev Agent after implementation_

**Expected New Files:**
- `contracts/MultiTokenPaymentChannelFactory.sol`
- `contracts/test/MockUSDC.sol`
- `contracts/test/MockCRO.sol`
- `test/MultiTokenPaymentChannelFactory.test.ts`

**Expected Modified Files:**
- `contracts/README.md` (updated with multi-token factory documentation)

---

## QA Results

_To be populated by QA reviewer after testing_
